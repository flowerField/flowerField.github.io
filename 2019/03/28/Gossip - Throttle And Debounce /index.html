<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Gossip - Throttle and Debounce · 花田半亩</title><meta name="description" content="Gossip - Throttle and Debounce - 文顶顶"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/logo.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://weibo.com/u/3800117445/atom.xml" title="花田半亩"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="花田半亩" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/%E9%B2%B8%E9%B1%BC.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文顶顶</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="/tool/" target="_self" class="nav-list-link">工具</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/wendingding/" target="_blank" class="nav-list-link">博客园</a></li><li class="nav-list-item"><a href="https://github.com/flowerField" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Gossip - Throttle and Debounce</h1><div class="post-info">Mar 28, 2019<span class="post-count"></span> ✧ 字数统计:2.3k(字) &nbsp;&nbsp; ♨︎ 阅读时长:9(分钟)</div><div class="post-content"><div class='tip'>本文讨论前端开发中 函数防抖 和 函数节流，它们的应用、区别以及简单实现。</div>

<p>在前端开发中我们可能经常需要给(页面)标签绑定一些持续触发的事件，如 <code>resize</code>、<code>scroll</code>、<code>input</code>、<code>mousemove</code>、<code>keyup</code>和<code>keydown</code> 等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p>
<p>譬如，如果用户有频繁的<code>resize</code> 和 <code>scroll</code> 行为，那么会导致页面不断的被重新渲染，如果在绑定的回调函数中存在大量的 DOM 操作，那么还会出现页面的卡顿，针对这种情况，常用的解决方式就是利用**节流( <a href="">throttle</a> )<strong>和</strong>防抖( <a href="">debounce</a> )**来优化高频事件，降低代码的执行频率。</p>
<p>若想对比默认情况、函数节流和函数防抖的情况，可以参考<a target="_blank" rel="noopener" href="https://codepen.io/chriscoyier/embed/vOZNQV?height=736&amp;theme-id=1&amp;slug-hash=vOZNQV&amp;default-tab=result&amp;user=chriscoyier&amp;name=cp_embed_1">演示效果-点击我</a>来直观感受它们的区别。</p>
<div class="titleX"><strong>函数节流</strong></div>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 原先： 1秒 执行 100次 --&gt;</span><br><span class="line">&lt;!-- 调节： 1秒 执行 1次--&gt;</span><br><span class="line">&lt;!-- 10秒钟执行1000次任务调整后10秒钟最多执行10次 --&gt;</span><br><span class="line">&lt;!-- 换个例子 --&gt;</span><br><span class="line">&lt;!-- 原先： 1秒中从池塘中流水100L --&gt;</span><br><span class="line">&lt;!-- 调节： 1秒钟从池塘中流水1L --&gt;</span><br><span class="line">&lt;!-- 10秒钟流出1000L水调整后10秒钟最多流出10L 水，这就是节流的操作。 --&gt;</span><br></pre></td></tr></table></figure>
<p><strong>函数节流</strong> 可以通过<code>时间戳</code>来实现。</p>
<p>下面，我们试着以代码的方式来探究函数节流的细节和具体实现。<br>我们在页面中提供一个按钮，给按钮绑定点击事件，那么正常情况是每当按钮点击一次的时候，对应的事件处理函数就会被触发执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 页面标签： &lt;button&gt;按钮&lt;/button&gt;  */</span></span><br><span class="line"><span class="keyword">let</span> task = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;click button&quot;</span>, e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oBtn = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">oBtn.addEventListener(<span class="string">&quot;click&quot;</span>, task);</span><br></pre></td></tr></table></figure>
<p>如果用户在短时间内快速连续多次的点击按钮，那么事件处理函数也会随之触发很多次。<span style="color:red"><strong>函数节流</strong>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效</span>。换言之，函数节流控制在固定的时间单位内，事件任务只会执行(生效)一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 事件处理函数 */</span></span><br><span class="line"><span class="keyword">let</span> task = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;click button&quot;</span>, e);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数节流 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        context = <span class="built_in">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 绑定事件 */</span></span><br><span class="line"><span class="keyword">let</span> oBtn = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">oBtn.addEventListener(<span class="string">&quot;click&quot;</span>, throttle(task, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p>上面给出了函数节流的简单实现方式，代码中封装了<code>throttle 函数</code>，该函数接收任何(事件)函数和间隔时间两个参数，并返回一个新在函数中。<code>throttle 函数</code>的核心是，在返回的函数中通过获取当前<code>时间戳</code>并和间隔时间进行比较的方式来控制是否应该执行任务函数。</p>
<p>当事件处理函数第一次执行后，后续点击事件被触发的时候，如果<code>now - previous &gt; wait</code> 成立(距离上次事件触发的时间已经超过了指定间隔时间)，那么则执行任务函数，否则就忽略这次点击事件。注意<code>func.apply(context, args)</code>这行代码的作用是，把具体的标签绑定给事件处理函数中的<code>this</code>, 此外在事件处理函数中可能还会存在事件对象等参数的传递，需要考虑到这种情况。</p>
<div class='tip'>关于函数节流的代码实现，我们还可以阅读和参考下知名框架[ underscore ](https://github.com/jashkenas/underscore/blob/master/underscore.js)的写法，该框架对函数节流提供了更精确的控制，譬如可以通过传递参数的方式来控制 第一次点击事件是否生效，以及最后一次的点击是否要触发等，下面给出其函数节流代码的核心实现。</div>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout,args, context, previous = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        context = <span class="built_in">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 该行代码设置第一次点击不生效 */</span></span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> remaning = wait - (now - previous);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果：是第一次触发事件 */</span></span><br><span class="line">        <span class="comment">/* 那么：执行事件处理函数，并更新previous值，如果有定时器，那么就进行清理操作 */</span></span><br><span class="line">        <span class="keyword">if</span> (remaning &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">/* 如果：不是第一次触发事件 &amp;&amp; 定时器为空 &amp;&amp;  trailing == true */</span></span><br><span class="line">        <span class="comment">/* 那么：总是执行最后一次的事件触发的处理函数 */</span></span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">                previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="built_in">Date</span>.now();</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                args = context = <span class="literal">null</span></span><br><span class="line">            &#125;, remaning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任何处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oBtn.addEventListener(<span class="string">&#x27;click&#x27;</span>, throttle(task, <span class="number">1000</span>, &#123;</span><br><span class="line">    <span class="attr">leading</span>: <span class="literal">false</span>,<span class="comment">/* 设置为 false的时候，第一次点击不生效 */</span></span><br><span class="line">    <span class="attr">trailing</span>: <span class="literal">true</span> <span class="comment">/* 设置最终一次点击总是触发 */</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<div class="titleX"><strong>函数防抖</strong></div>

<p>函数防抖（<a href="">debounce</a>）就是指<span style="color:red">触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会从头重新计算函数执行时间</span>。</p>
<p><strong>函数防抖</strong> 可以通过<code>定时器</code>来实现。</p>
<p>我们假设，当点击页面按钮的时候，在1秒的时间内事件处理函数只能执行一次，如果下次点击按钮的时候还没有超过1秒这个时间间隔，那么就重新开始计时。下面给出一份简单的代码实现供大家参考：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;button&gt;&lt;/button&gt; */</span></span><br><span class="line"><span class="comment">/* 任务执行函数 */</span></span><br><span class="line"><span class="keyword">let</span> task = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;task&quot;</span>, e);  </span><br><span class="line"><span class="comment">/* 防抖函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer); <span class="comment">/* 先清理以前的定时器(延迟函数) */</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;  </span><br><span class="line">        <span class="comment">/* 开启定时器，指定时间后执行任务函数 task */</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* 获取标签 */</span></span><br><span class="line"><span class="keyword">let</span> oBtn = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="comment">/* 注册事件 */</span></span><br><span class="line">oBtn.addEventListener(<span class="string">&quot;click&quot;</span>, debounce(task, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p>稍微调整下上面的代码，假设我们想要通过一个参数来控制是否要在第一次触发事件的时候，执行任务函数，那么可以参考下面的写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;button&gt;&lt;/button&gt; */</span></span><br><span class="line"><span class="comment">/* 任务执行函数 */</span></span><br><span class="line"><span class="keyword">let</span> task = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;task&quot;</span>, e);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">防抖函数</span></span><br><span class="line"><span class="comment">func:具体的事件处理函数(任务函数)</span></span><br><span class="line"><span class="comment">wait:规定的时间(单位毫秒)</span></span><br><span class="line"><span class="comment">immediate：布尔型参数，开始的时候是否先执行一次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer); <span class="comment">/* 清理以前的定时器(延迟函数) */</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 是否要在最开始的时候，先执行一次 */</span></span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">let</span> callNow = !timer;</span><br><span class="line">            <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 开启定时器，指定时间后执行任务函数 task */</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取标签 */</span></span><br><span class="line"><span class="keyword">let</span> oBtn = <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="comment">/* 注册事件 */</span></span><br><span class="line">oBtn.addEventListener(<span class="string">&quot;click&quot;</span>, debounce(task, <span class="number">1000</span>, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<p>总结下,<code>函数防抖</code> 和 <code>函数节流</code>都是防止某一事件的频繁触发，但原理却不一样：<strong>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行</strong>。</p>
<div class="titleX"><strong>源码赏析</strong></div>

<p>最后，简单贴出著名框架 <a target="_blank" rel="noopener" href="https://lodash.com/">lodash</a> 中关于函数防抖和函数节流的部分演示代码，并附上 Github<a target="_blank" rel="noopener" href="https://github.com/lodash/lodash/">开源地址</a>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* debounce.js 文件实现 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> maxWait;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;maxWait&#x27;</span> <span class="keyword">in</span> opts) &#123;</span><br><span class="line">        maxWait = opts.maxWait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> leading = <span class="literal">true</span>; <span class="comment">// 第一次点击时触发</span></span><br><span class="line">    <span class="keyword">let</span> trailing = <span class="literal">true</span>; <span class="comment">// 最后一次也要触发</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lastCallTime; <span class="comment">// 最后调用的时间 previous</span></span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">let</span> lastThis; <span class="comment">// 返回函数的this</span></span><br><span class="line">    <span class="keyword">let</span> lastArgs; <span class="comment">// 返回函数的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// shouldInvoke 表示是否应该调用</span></span><br><span class="line">    <span class="keyword">let</span> lastInvokeTime;</span><br><span class="line">    <span class="keyword">let</span> shouldInvoke = <span class="function"><span class="keyword">function</span>(<span class="params">now</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sinceLastTime = now - lastCallTime;</span><br><span class="line">        <span class="keyword">let</span> sinceLastInvoke = now - lastInvokeTime;</span><br><span class="line">        <span class="comment">// 第一次</span></span><br><span class="line">        <span class="keyword">return</span> lastCallTime === <span class="literal">undefined</span> </span><br><span class="line">        || sinceLastTime &gt; wait </span><br><span class="line">        || sinceLastInvoke &gt;= maxWait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leadingEdge 是否第一次执行</span></span><br><span class="line">    <span class="keyword">let</span> invokeFunc = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 最终的调用函数的时间</span></span><br><span class="line">        lastInvokeTime = time;</span><br><span class="line">        func.apply(lastThis, lastArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// startTimer就是开启了一个定时器</span></span><br><span class="line">    <span class="keyword">let</span> startTimer = <span class="function"><span class="keyword">function</span>(<span class="params">timerExpired, wait</span>) </span>&#123;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(timerExpired, wait);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> remainingWait = <span class="function"><span class="keyword">function</span>(<span class="params">now</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wait - (now - lastCallTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> trailingEdge = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        timeout = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">if</span> (trailing) &#123;</span><br><span class="line">            invokeFunc(time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> timerExpired = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now(); <span class="comment">// 当前定时器到时间了 看看是否需要执行这个函数</span></span><br><span class="line">        <span class="keyword">if</span> (shouldInvoke(now)) &#123; <span class="comment">// 如果需要调用，那么就触发结束的方法</span></span><br><span class="line">            <span class="keyword">return</span> trailingEdge(now);</span><br><span class="line">        &#125;</span><br><span class="line">        startTimer(timerExpired, remainingWait(now));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> leadingEdge = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        lastInvokeTime = time;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要执行那么就调用函数</span></span><br><span class="line">        <span class="keyword">if</span> (leading) &#123;</span><br><span class="line">            invokeFunc(time)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启一个定时器 看下一次定时器到了 是否需要执行func</span></span><br><span class="line">    startTimer(timerExpired, wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> debounced = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        lastThis = <span class="built_in">this</span>;</span><br><span class="line">        lastArgs = args;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前的debounce时是否需要执行</span></span><br><span class="line">        <span class="keyword">let</span> isInvoking = shouldInvoke(now);</span><br><span class="line">        lastCallTime = now;</span><br><span class="line">        <span class="keyword">if</span> (isInvoking) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                leadingEdge(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* throttle.js 文件实现 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> debounce(func, wait, &#123;</span><br><span class="line">        <span class="comment">// maxWait最大的点击时间</span></span><br><span class="line">        <span class="attr">maxWait</span>: wait</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src='../../../../z.png' width="200px">

<ul>
<li>Posted by 博客园·<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a> | <a target="_blank" rel="noopener" href="http://wendingding.com/">花田半亩</a></li>
<li>联系作者 简书·<a target="_blank" rel="noopener" href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&mod=TAB#place">Coder_文顶顶</a></li>
<li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/04/04/Gossip%20-%20Rollup/" class="prev">上一篇</a><a href="/2019/03/24/Gossip%20-%20TS%E3%80%81Class%20and%20ES5/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://weibo.com/u/3800117445">文顶顶</a> &nbsp;☁ 全站字数统计 418.8k (字)</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>