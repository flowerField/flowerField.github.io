<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> javaScript系列 [04]-javaScript的原型链 · 花田半亩</title><meta name="description" content="javaScript系列 [04]-javaScript的原型链 - 文顶顶"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/logo.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://weibo.com/u/3800117445/atom.xml" title="花田半亩"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="花田半亩" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文顶顶</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/wendingding/" target="_blank" class="nav-list-link">博客园</a></li><li class="nav-list-item"><a href="https://github.com/flowerField" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">javaScript系列 [04]-javaScript的原型链</h1><div class="post-info">Apr 15, 2018<span class="post-count"></span> ✧ 字数统计:3.1k(字) &nbsp;&nbsp; ♨︎ 阅读时长:12(分钟)</div><div class="post-content"><blockquote>
<p>本文旨在花很少的篇幅讲清楚JavaScript语言中的原型链结构，很多朋友认为JavaScript中的原型链复杂难懂，其实不然，它们就像树上的一串猴子。</p>
</blockquote>
<h4 id="1-1-理解原型链"><a href="#1-1-理解原型链" class="headerlink" title="1.1 理解原型链"></a>1.1 理解原型链</h4><p>JavaScript中几乎所有的东西都是对象，我们说数组是对象、DOM节点是对象、函数等也是对象，创建对象的Object也是对象（本身是构造函数），那么有一个重要的问题：<code>对象从哪里来？</code></p>
<p>这是一句废话，对象当然是通过一定方式创建出来的，根据实际类型不同，对象的创建方式也千差万别。比如函数，我们可以声明函数、使用Function构造函数创建等，比如数组，我们可以直接通过var arr  = [] 的方式创建空数组，也可以通过new Array的方式创建，比如普通的对象，我们可以字面量创建、使用内置构造函数创建等等，花样太多了，以至于我们学习的时候头昏脑涨、不得要领。</p>
<p><span style='color:red'>其实，归根结底所有“类型”的对象都可以认为是由相应构造函数创建出来的。</span> 函数由Function构造函数实例化而来，普通对象由Object构造函数实例化而来，数组对象由Array构造函数实例化而来，至于Object | Array | Function等他们本身是函数，当然也有自己的构造函数。</p>
<p>理解了上面一点，那么接下来我们在理解原型链的时候就会容易得多。</p>
<blockquote>
<p>请看刺激的推导过程</p>
<p>前提 所有对象都由构造函数实例化而来，构造函数默认拥有与之相关联的原型对象<br>❒  ① 构造函数的原型对象也是对象，因此也有自己的构造函数<br>❒  ② 构造函数原型对象的构造函数，也有与之相关连的原型对象<br>❒  ③ 构造函数原型对象的原型对象（<code>__proto__</code>）也有自己的构造函数，其也拥有关联的原型对象<br>☞ 以上就形成了一种链式的访问结构，是为<code>原型链</code>。</p>
</blockquote>
<div class='tip'>
其实构造函数也是对象，所以构造函数本身作为对象而言也有自己的构造函数，而这个构造函数也拥有与之相关联的原型对象，以此类推。那么，这就是另一条原型链了。综上，我们可以得出`原型链并不孤单`的结论。<div>

<h4 id="1-2-原型链结构"><a href="#1-2-原型链结构" class="headerlink" title="1.2 原型链结构"></a>1.2 原型链结构</h4><p>现在我们基本上把原型链的由来说清楚了，那么接下来通过具体的代码来分析原型链的整体结构。</p>
<p>示例代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//01 自定义构造函数Person和Animal</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//02 使用构造函数创建实例对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//03 创建数组对象</span></span><br><span class="line"><span class="keyword">var</span> arrM = [<span class="string">&quot;demoA&quot;</span>,<span class="string">&quot;demoB&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>上面的代码非常简单，其中p1，p2和a它们是自定义构造函数的实例化对象。其次，我们采用快捷方式创建了arrM数组，arrM其实是内置构造函数Array的实例化对象。另外，Person和Animal这两个构造函数其实是Function构造函数的实例对象。理解以上几点后，我们就可以来看一下这几行代码对应的原型链结构图了。</p>
<img src='../../../../src/js_07.png'>

<p>原型链结构图说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">① 因为复杂度关系，arrM对象的原型链结构图单独给出。</span><br><span class="line">② Object.prototype是所有原型链的顶端，终点为null。</span><br></pre></td></tr></table></figure>
<p>验证原型链相关的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//[1] 验证p1、p2的原型对象为Person.prototype</span></span><br><span class="line"><span class="comment">//    验证a    的原型对象为Animal.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__ == Person.prototype); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.__proto__ == Person.prototype); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ == Animal.prototype);  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[2] 获取Person.prototype|Animal.prototype构造函数</span></span><br><span class="line"><span class="comment">//    验证Person.prototype|Animal.prototype原型对象为Object.prototype</span></span><br><span class="line"><span class="comment">//    先删除实例成员，通过原型成员访问</span></span><br><span class="line"><span class="keyword">delete</span>  Person.prototype.constructor;</span><br><span class="line"><span class="keyword">delete</span>  Animal.prototype.constructor;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == <span class="built_in">Object</span>);    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.constructor == <span class="built_in">Object</span>);    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ == <span class="built_in">Object</span>.prototype);    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.__proto__ == <span class="built_in">Object</span>.prototype);    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[3] 验证Person和Animal的构造函数为Function</span></span><br><span class="line"><span class="comment">//    验证Person和Animal构造函数的原型对象为空函数</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ == <span class="built_in">Function</span>.prototype);        <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.__proto__ == <span class="built_in">Function</span>.prototype);        <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[4] 验证Function.prototype的构造函数为Function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.constructor == <span class="built_in">Function</span>);    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[5] 验证Function和Object的构造函数为Function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.constructor == <span class="built_in">Function</span>);              <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[6] 验证Function.prototype的原型对象为Object.prototype而不是它自己</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[7] 获取原型链的终点</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);                    <span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<p>下面贴出数组对象的原型链结构图<br><img src='../../../../src/js_08.png'></p>
<p>验证数组对象原型链结构的代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//[1] 验证arrM的构造函数为Array</span></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="built_in">console</span>.log(arrM.constructor == <span class="built_in">Array</span>);                 <span class="comment">//true</span></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arrM));      <span class="comment">//[object Array]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[2] 验证Array的构造函数为Function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.constructor == <span class="built_in">Function</span>);             <span class="comment">//true</span></span><br><span class="line"><span class="comment">//[3] 验证Array构造函数的原型对象为Function.prototype(空函数)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ == <span class="built_in">Function</span>.prototype);     <span class="comment">//true</span></span><br><span class="line"><span class="comment">//[4] 验证Array.prototype的构造函数为Object,原型对象为Object.prototype</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Array</span>.prototype.constructor;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.constructor == <span class="built_in">Object</span>);         <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-原型链的访问"><a href="#1-3-原型链的访问" class="headerlink" title="1.3 原型链的访问"></a>1.3 原型链的访问</h4><p><strong>原型链的访问规则</strong><br><span style='color'><br>对象在访问属性或方法的时候，先检查自己的实例成员，如果存在那么就直接使用，如果不存在那么找到该对象的原型对象，查找原型对象上面是否有对应的成员，如果有那么就直接使用，如果没有那么就顺着原型链一直向上查找，如果找到则使用，找不到就重复该过程直到原型链的顶端，此时如果访问的是属性就返回undefined，方法则报错。<br></span></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;wendingding&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>:Person,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;自来熟&quot;</span>,</span><br><span class="line">    <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name.lastIndexOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p.name);   <span class="comment">//访问的是实例成员上面的name属性：wendingding</span></span><br><span class="line">p.showName();          <span class="comment">//打印wendingding</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age);    <span class="comment">//该属性原型链中并不存在，返回undefined</span></span><br><span class="line">p.showAge();           <span class="comment">//该属性原型链中并不存在，报错</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>概念和访问原则说明<br>❐ 实例成员：实例对象的属性或者是方法<br>❐ 原型成员：实例对象的原型对象的属性或者是方法<br>❐ 访问原则：就近原则</p>
</blockquote>
<h4 id="1-4-getPrototypeOf、isPrototypeOf和instanceof"><a href="#1-4-getPrototypeOf、isPrototypeOf和instanceof" class="headerlink" title="1.4 getPrototypeOf、isPrototypeOf和instanceof"></a>1.4 getPrototypeOf、isPrototypeOf和instanceof</h4><p><strong>Object.getPrototypeOf方法</strong>用于获取指定实例对象的原型对象，用法非常简单，只需要把实例对象作为参数传递，该方法就会把当前实例对象的原型对象返回给我们。说白了，Object的这个静态方法其作用就是<span style='color:red'>返回实例对象<code>__proto__</code>属性指向的原型prototype。</span></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//01 声明构造函数F</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//02 使用构造函数F获取实例对象f</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="comment">//03 测试getPrototypeOf方法的使用</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(f));  <span class="comment">//打印的结果为一个对象，该对象是F相关联的原型对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(f) === F.prototype);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(f) === f.__proto__);  <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>isPrototypeOf方法</strong>用于检查某对象是否在指定对象的原型链中，如果在，那么返回结果true，否则返回结果false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//01 声明构造函数Person</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//02 获取实例化对象p</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">//03 测试isPrototypeOf的使用</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(p)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(p)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.isPrototypeOf(arr));    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(arr));   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(Person));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码的原型链<br> ① p–&gt;Person.prototype –&gt;Object.prototype –&gt;null<br> ② arr–&gt;Array.prototype –&gt;Object.prototype –&gt;null<br>Object.prototype因处于所有原型链的顶端，故所有实例对象都继承于Object.prototype</p>
</blockquote>
<p><strong>instanceof运算符</strong>的作用跟isPrototypeOf方法类似，左操作数是待检测的实例对象，右操作数是用于检测的构造函数。<span style='color:red'>如果右操作数指定构造函数的原型对象在左操作数实例对象的原型链上面，则返回结果true，否则返回结果false。</span></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//01 声明构造函数Person</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//02 获取实例化对象p</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">//03 测试isPrototypeOf的使用</span></span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person);   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//04 Object构造函数的原型对象在Function这个实例对象的原型链中</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//05 Function构造函数的原型对象在Object这个实例对象的原型链中</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<div class='tip'>
注意：不要错误的认为instanceof检查的是`该实例对象是否从当前构造函数实例化创建的`,其实它检查的是实例对象是否从当前指定构造函数的原型对象继承属性。
<div>

<p>我们可以通过下面给出的代码示例来进一步理解</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//01 声明构造函数Person</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//02 获取实例化对象p</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">//03 测试isPrototypeOf的使用</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//04 替换Person默认的原型对象</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>:Person,</span><br><span class="line">    <span class="attr">showInfo</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//05 重置了构造函数原型对象之后，因为Person</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//06 在Person构造函数重置了原型对象后重新创建实例化对象</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//==&gt; 建议开发中，总是先设置构造函数的原型对象，之后在创建实例化对象</span></span><br></pre></td></tr></table></figure>

<p>贴出上面代码的原型链结构图（部分）</p>
<img src='../../../../src/js_09.png'>

<h4 id="1-5-原型链相关的继承"><a href="#1-5-原型链相关的继承" class="headerlink" title="1.5 原型链相关的继承"></a>1.5 原型链相关的继承</h4><p>继承是面向对象编程的基本特征之一，JavaScript支持面向对象编程，在实现继承的时候，有多种可行方案。接下来，我们分别来认识下<code>原型式继承、原型链继承以及在此基础上演变出来的组合继承</code>。</p>
<p><strong>原型式继承基本写法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//01 提供超类型|父类型构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></span><br><span class="line">SuperClass.prototype.info = <span class="string">&#x27;SuperClass的信息&#x27;</span>;</span><br><span class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.info);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//03 提供子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//04 设置继承(原型对象继承)</span></span><br><span class="line">SubClass.prototype = SuperClass.prototype;</span><br><span class="line">SubClass.prototype.constructor = SubClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubClass();</span><br><span class="line"><span class="built_in">console</span>.log(sub.info);          <span class="comment">//SuperClass的信息</span></span><br><span class="line">sub.showInfo();                 <span class="comment">//SuperClass的信息</span></span><br></pre></td></tr></table></figure>
<p>贴出原型式继承结构图<br><img src='../../../../src/js_10.png'></p>
<div class='tip'>提示 该方式可以继承超类型中的原型成员，但是存在和超类型原型对象共享的问题<div>

<p><strong>原型链继承</strong></p>
<p>实现思想</p>
<blockquote>
<p>核心：把父类的实例对象设置为子类的原型对象 SubClass.prototype = new SuperClass();<br>问题：无法为父构造函数（SuperClass）传递参数</p>
</blockquote>
<p><strong>原型链继承基本写法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//01 提供超类型|父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;SuperClass的名称&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></span><br><span class="line">SuperClass.prototype.info = <span class="string">&#x27;SuperClass的信息&#x27;</span>;</span><br><span class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.info);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//03 提供子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//04 设置继承(原型对象继承)</span></span><br><span class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> SuperClass();</span><br><span class="line">SubClass.prototype = sup;</span><br><span class="line">SubClass.prototype.constructor = SubClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubClass();</span><br><span class="line"><span class="built_in">console</span>.log(sub.name);          <span class="comment">//SuperClass的名称</span></span><br><span class="line"><span class="built_in">console</span>.log(sub.info);          <span class="comment">//SuperClass的信息</span></span><br><span class="line">sub.showInfo();                 <span class="comment">//SuperClass的信息</span></span><br><span class="line">sub.showName();                 <span class="comment">//SuperClass的名称</span></span><br></pre></td></tr></table></figure>

<p>贴出原型链继承结构图<br><img src='../../../../src/js_11.png'></p>
<p><strong>组合继承</strong></p>
<p>实现思想</p>
<blockquote>
<p>① 使用原型链实现对原型属性和方法的继承<br>② 通过伪造(冒充)构造函数来实现对实例成员的继承，并且解决了父构造函数传参问题</p>
</blockquote>
<p><strong>组合继承基本写法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//01 提供超类型|父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></span><br><span class="line">SuperClass.prototype.info = <span class="string">&#x27;SuperClass的信息&#x27;</span>;</span><br><span class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.info);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//03 提供子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    SuperClass.call(<span class="built_in">this</span>,name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)获取父构造函数的实例成员  Person.call(this,name);</span></span><br><span class="line"><span class="comment">//(2)获取父构造函数的原型成员  SubClass.prototype = SuperClass.prototype;</span></span><br><span class="line">SubClass.prototype = SuperClass.prototype;</span><br><span class="line">SubClass.prototype.constructor = SubClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub_one = <span class="keyword">new</span> SubClass(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sub_two = <span class="keyword">new</span> SubClass(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub_one);</span><br><span class="line"><span class="built_in">console</span>.log(sub_two);</span><br></pre></td></tr></table></figure>
<p>最后，贴出实例对象sub_one和sub_two的打印结果</p>
<img src='../../../../src/js_12.png' height='200'>

<img src='../../../../z.png' width="200px">

<hr>
<ul>
<li>Posted by 博客园·<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a> | <a target="_blank" rel="noopener" href="http://wendingding.com/">花田半亩</a></li>
<li>联系作者 简书·<a target="_blank" rel="noopener" href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&mod=TAB#place">Coder_文顶顶</a></li>
<li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/16/javaScript%E7%B3%BB%E5%88%97%20%5B05%5D-javaScript%E5%92%8CJSON/" class="prev">上一篇</a><a href="/2018/04/14/javaScript%E7%B3%BB%E5%88%97%20%5B03%5D-javaScript%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://weibo.com/u/3800117445">文顶顶</a> &nbsp;☁ 全站字数统计 420.5k (字)</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>