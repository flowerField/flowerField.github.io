<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> javaScript系列 [01]-javaScript函数基础 · 花田半亩</title><meta name="description" content="javaScript系列 [01]-javaScript函数基础 - 文顶顶"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/logo.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://weibo.com/u/3800117445/atom.xml" title="花田半亩"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="花田半亩" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/%E9%B2%B8%E9%B1%BC.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文顶顶</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="/tool/" target="_self" class="nav-list-link">工具</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/wendingding/" target="_blank" class="nav-list-link">博客园</a></li><li class="nav-list-item"><a href="https://github.com/flowerField" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">javaScript系列 [01]-javaScript函数基础</h1><div class="post-info">Apr 11, 2018<span class="post-count"></span> ✧ 字数统计:4k(字) &nbsp;&nbsp; ♨︎ 阅读时长:15(分钟)</div><div class="post-content"><h4 id="1-1-函数的创建和结构"><a href="#1-1-函数的创建和结构" class="headerlink" title="1.1  函数的创建和结构"></a>1.1  函数的创建和结构</h4><p><strong>函数的定义</strong>：函数是JavaScript的基础模块单元，包含一组语句，用于代码复用、信息隐蔽和组合调用。</p>
<p><strong>函数的创建</strong>：在javaScript语言中，可以说函数是其最重要也最成功的设计。我们可以通过三种方式来创建函数。</p>
<p><code>① 函数声明</code><br><code>② 字面量方式创建</code><br><code>③ 使用Function构造函数创建 </code></p>
<p>代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//01 函数声明</span></span><br><span class="line"><span class="comment">//函数名称为：f1,a和b为该函数的形式参数（形参）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//02 字面量创建函数</span></span><br><span class="line"><span class="comment">//使用字面量创建匿名函数并赋值给f2,可以通过f2来调用,a和b为该函数的形式参数（形参）</span></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//03 构造函数创建</span></span><br><span class="line"><span class="comment">//f3函数为Function这个构造函数的实例化对象，如果不传递参数，那么创建出来的函数没有任何用处。</span></span><br><span class="line"><span class="comment">//在创建实例对象的时候我们可以通过参数列表的方式来指定f3的结构。</span></span><br><span class="line"><span class="comment">//构造函数的参数中最后一个参数为函数体的内容，其余均为函数的形参。</span></span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;return a + b&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的调用</span></span><br><span class="line"><span class="built_in">console</span>.log(f1(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(f2(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(f3(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p><strong>函数的结构</strong><br>函数的一般表现形式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n1,n2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//函数体的内容</span></span><br><span class="line">    <span class="keyword">return</span> n1 + n2; <span class="comment">//返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，函数包括四个部分：<br>（1）保留字，function。<br>（2）函数名，这里为fn。<br>（3）圆括号以及包围在圆括号中的一组参数。<br>（4）包括在花括号中的一组语句。</p>
<blockquote>
<p>❐ 函数名可以被省略（称为匿名函数），函数名可用于函数调用或者是递归调用，另外函数名可以被调试器和开发工具识别。</p>
</blockquote>
<blockquote>
<p>❐ 函数声明时的参数为形参，可以有多个，多个参数之间使用逗号进行分隔。<code>形参将在函数调用的时候被定义为函数中的局部变量，[注意]形参并不会像普通变量一样被初始化为undefined，它们的值根据函数调用时传入的实际参数值设置。</code>另外，函数调用的时候并不会对实参的类型进行检查。</p>
</blockquote>
<blockquote>
<p>❐ 函数体是一组语句，它们在函数<code>被调用</code>的时候执行。函数执行完毕后，会返回一个值。</p>
</blockquote>
<p> <strong>函数的调用</strong>：函数声明后可以通过（）运算符来进行调用，JavaScript语言中，只有函数可以被调用。当函数被调用的时候，如果存在参数传递，那么会把实参的值传递给形参，并按照从上到下的顺序逐条执行函数体内部的代码。</p>
<h4 id="1-2-函数和对象的关系"><a href="#1-2-函数和对象的关系" class="headerlink" title="1.2  函数和对象的关系"></a>1.2  函数和对象的关系</h4><p>JavaScript中的函数本质上就是对象。<br>在使用typeof 关键字对数据进行类型检查的时候，得到的结果可能会让我们产生错觉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">   <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o);      <span class="comment">//object</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);      <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>实际上，函数和对象没有质的区别，函数是特殊的对象。</p>
<blockquote>
<p>函数的特殊性<br>① 函数可以被（）运算符调用[最重要]。<br>② 函数可以创建独立的作用域空间。<br>③ 函数拥有标配的prototype属性。</p>
</blockquote>
<p>因为函数本身就是对象，所以在代码中函数可以像对象一样被使用，凡是对象可以出现的地方函数都可以出现。</p>
<blockquote>
<p>❐ 函数可以拥有属性和方法。<br>❐ 函数可以保存在变量、对象和数组中。<br>❐ 函数可以作为其它函数的参数（称为函数回调）。<br>❐ 函数可以作为函数的返回值进行返回。</p>
</blockquote>
<p><strong>函数和对象的原型链结构</strong><br>我们可以通过下面列出的简单示例代码来分析对象的原型链结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//字面量方式创建普通的对象</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">&quot;文顶顶&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;18&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关于普通对象的结构研究</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;① 打印o对象\n&quot;</span>,o);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;② 打印o.__proto__\n&quot;</span>,o.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;③ 打印o.__proto__ === Object.prototype\n&quot;</span>,o.__proto__ === <span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;④ 打印o.constructor\n&quot;</span>,o.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;⑤ 打印o.constructor === Object\n&quot;</span>,o.constructor === <span class="built_in">Object</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过对该代码的运行和打印分析，可以得到下面的图示。<br><img src='../../../../src/js_01.png'></p>
<p>我们也可以使用同样的方式来分析函数对象的原型链结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用构造函数Function 来创建函数(对象)</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;return a + b&quot;</span>);</span><br><span class="line"><span class="comment">//调用函数，证明该函数是合法可用的</span></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">//得到打印结果5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关于函数对象的结构研究</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;① 打印函数对象\n&quot;</span>,f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;② 打印f.__proto__\n&quot;</span>,f.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;③ 打印f.__proto__===Function.prototype\n&quot;</span>,f.__proto__===<span class="built_in">Function</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;④ 打印f.constructor\n&quot;</span>,f.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;⑤ 打印f.constructor === Function\n&quot;</span>,f.constructor === <span class="built_in">Function</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意</span></span><br><span class="line"><span class="built_in">console</span>.log(f.hasOwnProperty(<span class="string">&quot;constructor&quot;</span>));   <span class="comment">//检查constructor是否为函数f的实例成员(false)</span></span><br><span class="line"><span class="built_in">console</span>.log(f.__proto__.hasOwnProperty(<span class="string">&quot;constructor&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>顺便贴出研究Function原型结构的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明：下面三行代码表明Function的原型对象指向一个空函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype);  <span class="comment">//ƒ () &#123; [native code] &#125;  是一个空函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Function</span>.prototype));  <span class="comment">//[object Function]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查Function.prototype的原型链结构</span></span><br><span class="line"><span class="comment">//Function.prototype是一个空函数，是一个对象，而对象均由构造函数实例化产生</span></span><br><span class="line"><span class="comment">//检查Function.prototype的构造函数以及原型对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.constructor  === <span class="built_in">Function</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：按照一般逻辑实例对象的__proto__(原型对象)应该指向创建该实例对象的构造函数的原型对象</span></span><br><span class="line"><span class="comment">//即此处应该表现为Function.prototype.__proto__---&gt;Function.prototype.constructor.prototype</span></span><br><span class="line"><span class="comment">//似乎可以得出推论：Function.prototype.__proto__ === Function.prototype == 空函数 但这是错误的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过对函数对象原型结构的代码探索，可以得到下图的原型链结构图（<code>注</code>：原型链并不完整）</p>
<img src='../../../../src/js_02.png'>

<p><strong>函数的其它隐藏细节</strong></p>
<p><span style="color:#ff3333">① 函数天生的prototype属性<span></p>
<p>每个函数对象在创建的时候会随配一个prototype属性，即每个函数在创建之后就天生拥有一个与之相关联的原型对象，这个关联的原型对象中拥有一个constructor属性，该属性指向这个函数。<br>简单描述下就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123; //......&#125;  //声明函数</span><br><span class="line">//函数声明被创建后，默认拥有prototype属性---&gt;原型对象（空对象）</span><br></pre></td></tr></table></figure>
<img src='../../../../src/js_03.png'>

<div class='tip'>
这里需要注意的是，很多人容易被自己的经验误导，认为新创建的函数对象身上除prototype实例属性外，还拥有constructor这个实例属性，因为我们经常看到` f.constructor类似的代码`，其实这里使用的constructor属性是从原型链中获取的，其实是f构造函数关联原型对象上面的属性，即Function.prototype.constructor。
<div>

<p style="border: 1px solid #666;">备注：在[ECMAScript标准中函数创建相关章节](https://www.ecma-international.org/ecma-262/5.1/#sec-13.2)有这样一句话：NOTE A prototype property is automatically created for every function, to allow for the possibility that the function will be used as a constructor.解释了给新创建函数添加prototype属性的意义在于便于该函数作为构造函数使用。</p>

<p><span style="color:#ff3333">② 函数何以能够被调用<span></p>
<p>我们已经理解了函数本身就是对象，但又区别于普通对象，最大的区别在于函数可以被调用，（）被称为调用运算符。</p>
<blockquote>
<p>❗️ 函数可以被调用的原因在于JavaScript创建一个函数对象时，会给该对象设置一个“调用”属性。当JavaScript调用一个函数时，可以理解为调用该函数的“调用”属性。</p>
</blockquote>
<h4 id="1-3-函数的调用和this参数"><a href="#1-3-函数的调用和this参数" class="headerlink" title="1.3  函数的调用和this参数"></a>1.3  函数的调用和this参数</h4><p>函数名后面跟上（）表明这是一个函数调用。<br><code>调用运算符：</code>是跟在任何产生一个函数值的表达式之后的一对圆括号。圆括号内可以包含N（N&gt;=0）个用逗号分隔开的表达式，每个表达式产生一个参数值。每个参数值被赋予函数声明时定义的形式参数名。</p>
<p><strong>函数的调用</strong><br>JavaScript中有四种调用函数的模式</p>
<p><code>① 对象方法调用模式</code><br><code>② 普通函数调用模式</code><br><code>③ 构造函数调用模式</code><br><code>③ 上下文的调用模式</code></p>
<p>除了声明函数时定义的形参外，每个函数还接收两个附加的参数，分别是this和arguments。其中arguments用于存储函数调用时接收到的实际参数，this的值则取决于函数的调用模式，下面分别讲解。</p>
<p><strong>普通函数调用模式</strong></p>
<p>当函数并不作为其他对象的属性，直接使用调用运算符来调用时，我们认为它使用<code>普通函数调用模式</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//01 声明函数fn</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//02 以普通函数调用模式来调用fn函数</span></span><br><span class="line">    fn(); <span class="comment">//this被绑定到全局对象window</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p style="border: 1px solid #666;">备注：在我们看来上面的调用方式非常简单清楚，而且this的指向也没有任何问题。但[JSON](http://json.org/)的作者[Douglas Crockford](https://zh.wikipedia.org/wiki/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%C2%B7%E5%85%8B%E7%BE%85%E5%85%8B%E7%A6%8F%E7%89%B9)指出这是JavaScript语言设计上的一个错误。因为把this直接绑定给全局变量的方式没有考虑到函数作为内部函数（在其它函数内部声明的函数）使用过程中需要共享外部对象访问权的问题。
他指出正确的语言设计应该是，`当内部函数被调用时，函数内的this应该和外部函数的this保持一致，即这个this应该被绑定到外部函数的this变量。`无疑，这值得思考和讨论。</p>

<p><strong>对象方法调用模式</strong></p>
<p>对象是键值对的集合，对象可以拥有属性和方法。<br>当函数被保存为对象的属性时，我们称之为方法。<br>对象的方法需要通过<code>对象.方法（）</code>或者是<code>对象[方法]（）</code>的方式进行调用。<br>以对象方法的模式来对函数进行调用，函数内部的this被绑定给该对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//01 字面量的方式创建对象</span></span><br><span class="line">   <span class="comment">//02 o对象中拥有name属性和showName方法</span></span><br><span class="line">   <span class="keyword">var</span> o = &#123;</span><br><span class="line">       <span class="attr">name</span>:<span class="string">&quot;文顶顶&quot;</span>,</span><br><span class="line">       <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);   <span class="comment">//文顶顶</span></span><br><span class="line">       &#125;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//03 以对象方法调用模式来调用showName函数</span></span><br><span class="line">   o.showName(); <span class="comment">//this被绑定到o对象</span></span><br></pre></td></tr></table></figure>

<p>❗️ this到对象的绑定发生在方法调用的时候。</p>
<p><strong>构造函数调用模式</strong></p>
<p><code>构造函数：</code>如果一个函数创建出来之后，我们总是希望使用new 前缀来调用它，那这种类型的函数就被称为构造函数。构造函数和普通函数本质上没有任何区别，开发者总是约定以函数名首字母大写的方式来人为进行区分。</p>
<p>如果以构造函数的方式来调用函数，那么在调用时，默认会创建一个连接到该构造函数原型对象上面的新对象，同时让this绑定到该新对象上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//01 声明构造函数Person</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//02 以构造函数的方式来调用Person</span></span><br><span class="line">   <span class="keyword">new</span> Person();  <span class="comment">//this被绑定到Person的实例化对象</span></span><br></pre></td></tr></table></figure>

<p>❗️ 构造函数调用方式也会改变函数中return语句的行为，如果显示的return语句后面跟着的不是对象类型的数据，那么默认返回this绑定的新对象。</p>
<p><strong>上下文的调用模式</strong></p>
<p>上下文的调用模式，即使用apply或则call方法来调用函数。<br>因为JavaScrip是一门函数式的面向对象编程语言，所有JavaScript中的函数本质上是对象，也因此函数也可以拥有方法。使用上下文模式对函数进行调用的时候，函数内部的this根据参数传递的情况进行绑定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明函数f</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(a, b, a+b);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>);       <span class="comment">//使用上下文模式调用时，this被绑定给o对象</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);  <span class="comment">//wendingding</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//字面量的方式创建对象</span></span><br><span class="line">   <span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">&quot;wendingding&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用apply和call方法来调用函数</span></span><br><span class="line">   f.apply(o, [<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line">   f.call(o,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.hasOwnProperty(<span class="string">&quot;apply&quot;</span>));                 <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.hasOwnProperty(<span class="string">&quot;apply&quot;</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>❐  apply和call方法调用函数，函数内部的this绑定给第一个参数。<br>❐  apply和call方法定义于Function的原型对象上，所以所有的函数都可访问。<br>❐  apply和call方法作用基本相同，参数传递的形式有所差别。</p>
</blockquote>
<h4 id="1-4-函数的参数（arguments）"><a href="#1-4-函数的参数（arguments）" class="headerlink" title="1.4  函数的参数（arguments）"></a>1.4  函数的参数（arguments）</h4><p>函数调用时，会完成实际参数对形式参数的赋值工作。<br>当实际参数的个数和形式参数的个数不匹配时，并不会导致运行错误。</p>
<blockquote>
<p>如果实际参数的数量过多，那么超出的那些参数会被忽略。<br>如果实际参数的数量不足，那么缺失的那些参数会被设置为undefined。<br>JavaScript在进行函数调用时不会对参数进行任何的类型检查。</p>
</blockquote>
<p>在函数的内部，我们总是可以获得一个免费配送的arguments参数。<br>arguments用于接收函数调用时传入的实际参数，它被设计成一个类似于数组的结构，拥有length属性，但因为它不是一个真正的数组所以不能使用任何数组对应的方法。</p>
<p>arguments参数的存在，使得我们可以编写一些无须指定形参个数的函数。<br>下面提供一份示例代码用于对传入的所有参数进行累加计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="built_in">arguments</span>.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">89</span>));   <span class="comment">//125</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h4 id="1-5-函数的返回值"><a href="#1-5-函数的返回值" class="headerlink" title="1.5  函数的返回值"></a>1.5  函数的返回值</h4><p><strong>函数的调用</strong>：调用一个函数会暂停当前代码的执行，把控制权和参数传递给正被调用的函数。当一个函数被调用的时候，它会先根据实际参数来对函数的形式参数进行初始化，然后从函数体中的第一个语句开始执行并遇到关闭函数体的 } 时结束。然后把控制权交还给调用该函数的上下文。</p>
<p><strong>函数的返回值</strong>：函数体中return语句可以用来让函数提前返回。当retun语句被执行时，函数会立即返回而不再执行余下的语句，return语句后面跟上返回的具体数据，可以是任意类型（包括函数）。</p>
<blockquote>
<p>❐ 函数总是会有一个返回值，如果没有使用return语句指定，那么将总是返回<code>undefined</code>。</p>
</blockquote>
<blockquote>
<p>❐ 函数的返回值还和它的调用方式有关系，如果使用new也就是也构造函数的方式来调用，若函数体中没有通过return语句显示的返回一个对象类型的数据，则<code>默认返回this（新创建的实例对象）</code>。</p>
</blockquote>
<blockquote>
<p>❗️ JavaScript不允许在return关键字和表达式之间换行。</p>
</blockquote>
<img src='../../../../z.png' width="200px">

<hr>
<ul>
<li>Posted by 博客园·<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a> | <a target="_blank" rel="noopener" href="http://wendingding.com/">花田半亩</a></li>
<li>联系作者 简书·<a target="_blank" rel="noopener" href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&mod=TAB#place">Coder_文顶顶</a></li>
<li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/13/javaScript%E7%B3%BB%E5%88%97%20%5B02%5D-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/" class="prev">上一篇</a><a href="/2018/04/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%20Mac%E7%B3%BB%E7%BB%9F%E4%B8%ADTree%E7%9A%84%E4%BD%BF%E7%94%A8/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://weibo.com/u/3800117445">文顶顶</a> &nbsp;☁ 全站字数统计 418.8k (字)</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>