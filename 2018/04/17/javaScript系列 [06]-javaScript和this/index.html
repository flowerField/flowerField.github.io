<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> javaScript系列 [06]-javaScript和this · 花田半亩</title><meta name="description" content="javaScript系列 [06]-javaScript和this - 文顶顶"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/logo.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://weibo.com/u/3800117445/atom.xml" title="花田半亩"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="花田半亩" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/%E9%B2%B8%E9%B1%BC.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文顶顶</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/wendingding/" target="_blank" class="nav-list-link">博客园</a></li><li class="nav-list-item"><a href="https://github.com/flowerField" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">javaScript系列 [06]-javaScript和this</h1><div class="post-info">Apr 17, 2018<span class="post-count"></span> ✧ 字数统计:5.9k(字) &nbsp;&nbsp; ♨︎ 阅读时长:22(分钟)</div><div class="post-content"><blockquote>
<p>在<a target="_blank" rel="noopener" href="http://wendingding.com/2018/04/11/javaScript%E7%B3%BB%E5%88%97%20[01]-javaScript%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC/">javaScript系列 [01]-javaScript函数基础</a>这篇文章中我已经简单介绍了JavaScript语言在函数使用中this的指向问题，虽然篇幅不长，但其实最重要的部分已经讲清楚了，这篇文章我们来单独谈一谈神秘的this，或者叫<code>怎么也搞不清楚的指天指地指空气的this</code>。</p>
</blockquote>
<h3 id="1-1-this简单说明"><a href="#1-1-this简单说明" class="headerlink" title="1.1 this简单说明"></a>1.1 this简单说明</h3><p><strong>this</strong>关键字被认为是JavaScript语言中最复杂的机制之一，跟this相关的知识很多开发者往往总是一知半解，更有甚者很多人完全搞不懂也不愿意去搞懂跟this相关的内容，在必须要用到的时候宁愿选择在代码中总是使用临时打印验证的方式来探知this的指向。这是现实，也许因为他们觉得跟this有关的这一切都混乱不堪，各种文档晦涩难懂，this的指向好似没有固定的套路，总是变来变去难以捉摸。其实，this原本并没有那么复杂，它就是个被自动定义在函数作用域中的变量，总是指向某个特定的“对象”。接下来，我们将尝试用这样一篇文章来讲清楚跟this有关的以下问题：</p>
<blockquote>
<p>❐   this 是什么？<br>❐   为什么要使用this?<br>❐   this指向谁？<br>❐   this绑定的几种情况<br>❐   this固定规则外的注意事项</p>
</blockquote>
<p><span style='border:1px solid #000'><strong>&nbsp; &nbsp;this是什么?&nbsp; &nbsp;</strong></span></p>
<p>在声明函数的时候，除了声明时定义的形式参数外，每个函数还接受两个附加的参数：<code>this</code>和<code>arguments</code>。其中arguments是一个类似于数组的结构，保存了函数调用时传递的所有实际参数，arguments这个参数让我们有能力编写<code>能够接受任意个数参数的</code>函数。参数this在面向对象编程中非常重要，它总是指向一个“特定的对象”，至于这个特定的对象是谁通常取决于函数的调用模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);  <span class="comment">//默认指向window</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">           res += <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用sum函数的时候，this默认指向window</span></span><br><span class="line">    <span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">//计算输入参数的累加和，结果为10</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>现在我们知道和this有关的关键信息是：</p>
<p><span style='color:#F55'>① this是JavaScript中所有函数的隐藏参数之一，因此每个函数中都能访问this。</span><br><span style='color:#F55'>② 函数中的this总是指向一个特定对象，该对象具体取决于函数的调用模式。</span></p>
<div class='tip'>
说明：在script标签中我们也可以直接访问this，它通常总是指向widow，我们讨论的this主要特指函数内部(函数体)的this。
</div>

<p><span style='border:1px solid #000'><strong>&nbsp; &nbsp;为什么要使用this?&nbsp; &nbsp;</strong></span></p>
<p><span style='color:#F55'>this提供一种更优雅的方式来隐士的传递一个对象引用，因为拥有this，所以我们可以把API设计得更加的简洁并且易于复用。简单点说，那就是this可以帮助我们省略参数。</span></p>
<p>我们可以通过以下两个代码片段来加深对this使用的理解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**代码 [ 01 ]**/</span></span><br><span class="line"><span class="keyword">var</span> personOne = &#123;<span class="attr">name</span>:<span class="string">&quot;文顶顶&quot;</span>,<span class="attr">contentText</span>:<span class="string">&quot;天王盖地虎 小鸡炖蘑菇&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> personTwo = &#123;<span class="attr">name</span>:<span class="string">&quot;燕赤霞&quot;</span>,<span class="attr">contentText</span>:<span class="string">&quot;天地无极 乾坤借法 急急如令令&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.name+<span class="string">&quot;口诀是：&quot;</span> + getContentText(obj));;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getContentText</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.contentText + <span class="string">&quot;哒哒哒哒~&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">speak(personOne);  <span class="comment">//文顶顶口诀是：天王盖地虎 小鸡炖蘑菇哒哒哒哒~</span></span><br><span class="line">speak(personTwo);  <span class="comment">//燕赤霞口诀是：天地无极 乾坤借法 急急如令令哒哒哒哒~</span></span><br><span class="line"></span><br><span class="line">getContentText(personOne);</span><br><span class="line">getContentText(personTwo);</span><br></pre></td></tr></table></figure>
<p><strong>代码说明：</strong>上面的代码声明了两个函数：speak和getContentText，这两个函数都需要访问对象中的属性，上面的代码中每个函数都接收一个obj对象作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**代码 [ 02 ]**/</span></span><br><span class="line"><span class="keyword">var</span> personOne = &#123;<span class="attr">name</span>:<span class="string">&quot;文顶顶&quot;</span>,<span class="attr">contentText</span>:<span class="string">&quot;天王盖地虎 小鸡炖蘑菇&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> personTwo = &#123;<span class="attr">name</span>:<span class="string">&quot;燕赤霞&quot;</span>,<span class="attr">contentText</span>:<span class="string">&quot;天地无极 乾坤借法 急急如令令&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>.name+<span class="string">&quot;口诀是：&quot;</span> + getContentText.call(<span class="built_in">this</span>));;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getContentText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.contentText + <span class="string">&quot;哒哒哒哒~&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">speak.call(personOne);  <span class="comment">//文顶顶口诀是：天王盖地虎 小鸡炖蘑菇哒哒哒哒~</span></span><br><span class="line">speak.call(personTwo);  <span class="comment">//燕赤霞口诀是：天地无极 乾坤借法 急急如令令哒哒哒哒~</span></span><br><span class="line"></span><br><span class="line">getContentText.call(personOne);  <span class="comment">//天王盖地虎 小鸡炖蘑菇哒哒哒哒~</span></span><br><span class="line">getContentText.call(personTwo);  <span class="comment">//天地无极 乾坤借法 急急如令令哒哒哒哒~</span></span><br></pre></td></tr></table></figure>
<p><strong>代码说明：</strong>完成相同的功能，还是两个同样的函数，区别在于我们借助this省略掉了函数必须要传递的对象参数，实现更优雅。而且如果你的代码越来越复杂，那么需要显式传递的上下文对象会让代码变得越来越混乱而难以维护，使用this则不会如此。</p>
<h3 id="1-2-函数和this"><a href="#1-2-函数和this" class="headerlink" title="1.2 函数和this"></a>1.2 函数和this</h3><p>this指向谁绑定给哪个对象并不是在编写代码的时候决定的，而是在运行时进行绑定的，它的上下文取决于函数调用时的各种条件 。<span style='color:F55'>this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</span></p>
<p>当函数被调用时，会创建一个执行上下文。该上下文会包含一些特殊的信息，例如函数在哪里被调用，函数的调用方式，函数的参数等，this其实是该上下文中的一个属性，它指向谁完全取决于函数的调用方式。</p>
<p>现在我们已经弄明白了this最核心的知识：<span style='color:#F55'>this的指向取决于函数的调用方式。</span></p>
<p><span style='border:1px solid #000'><strong>&nbsp; &nbsp;函数基础&nbsp; &nbsp;</strong></span></p>
<p>在接着讲解之前，有必要对函数的情况进行简单说明，比如函数的创建、参数的传递、函数的调用以及返回值等等。</p>
<p><strong>函数的创建</strong><br>在开发中我们有多种方式来创建（声明）函数，可以使用function关键字直接声明一个具名函数或者是匿名函数，也可以使用Function构造函数来创建一个函数实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//01 function关键字声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;命名函数|具名函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;匿名函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//02 Function构造函数创建函数实例对象</span></span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;console.log(&quot;函数实例对象的函数体&quot;)&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>函数的参数</strong><br>函数的参数有两种，一种是形式参数，一种是实际参数。</p>
<p><strong>形式参数</strong><br>在函数声明（创建）的时候，我们可以通过一定的方式来指定函数的参数，相当于在函数体内声明了对应的临时局部变量。</p>
<p><strong>实际参数</strong><br>在函数调用的时候，会把实际参数的值传递给形式参数，存在一个隐藏的赋值操作，实际参数就是函数调用时()中的参数。</p>
<p><strong>隐藏参数</strong><br>JavaScript中所有函数中均可以使用this和arguments这两个附加的隐藏参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[1] 函数的声明</span></span><br><span class="line"><span class="comment">//01 function关键字声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//a和b为函数的形式参数，相当于在此处写上代码 var a,b;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;命名函数|具名函数&quot;</span>,<span class="string">&quot;a的值:&quot;</span> +a , <span class="string">&quot;b的值:&quot;</span>+b);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);      <span class="comment">//此处指向window全局对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">//此处打印的是[&quot;f1的a&quot;,&quot;f1的b&quot;]结构的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//a和b为函数的形式参数，相当于在此处写上代码 var a,b;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;匿名函数&quot;</span>,<span class="string">&quot;a的值:&quot;</span> +a , <span class="string">&quot;b的值:&quot;</span>+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//02 Function构造函数创建函数实例对象</span></span><br><span class="line"><span class="comment">//a和b为新创建的函数对象的形式参数</span></span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;console.log(&quot;函数实例对象的函数体&quot;,&quot;a的值:&quot; +a , &quot;b的值:&quot;+b)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//[2] 函数的调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;f1的a&quot;和&quot;f1的b&quot;这两个字符串作为f1函数此处调用传递的实际参数</span></span><br><span class="line"><span class="comment">//在调用函数的时候，会把&quot;f1的a&quot;这个字符串赋值给形参a,把&quot;f1的b&quot;这个字符串赋值给形参b</span></span><br><span class="line">f1(<span class="string">&quot;f1的a&quot;</span>,<span class="string">&quot;f1的b&quot;</span>);  <span class="comment">//命名函数|具名函数 a的值:f1的a b的值:f1的b</span></span><br><span class="line"></span><br><span class="line">f2(<span class="string">&quot;f2的a&quot;</span>,<span class="string">&quot;f3的b&quot;</span>);  <span class="comment">//匿名函数 a的值:f2的a b的值:f3的b</span></span><br><span class="line">f3(<span class="string">&quot;f3的a&quot;</span>,<span class="string">&quot;f3的b&quot;</span>);  <span class="comment">//函数实例对象的函数体 a的值:f3的a b的值:f3的b</span></span><br></pre></td></tr></table></figure>
<p><strong>函数调用</strong><br>函数名后面跟上调用运算符<code>[()]</code>的代码，我们称为函数调用，当函数被调用的时候，会把实参赋值给形参并自上而下的执行函数体中的代码。</p>
<p><span style='border:1px solid #000'><strong>&nbsp; &nbsp;函数调用和this绑定&nbsp; &nbsp;</strong></span></p>
<p>因为this的绑定完全取决于函数的调用方式，所以要搞清楚this绑定问题只需要搞清楚函数调用方式即可，函数的调用方式通常来说有以下四种：</p>
<blockquote>
<p>❐   <span style='color:#f22'>普通函数调用(默认绑定)</span><br>❐   <span style='color:#f22'>对象方法调用(隐式绑定)</span><br>❐   <span style='color:#f22'>构造函数调用(new绑定)</span><br>❐   <span style='color:#f22'>函数上下文调用(显式绑定)</span></p>
</blockquote>
<p>函数的调用方式只有上面的四种情况，而要确定其具体的调用方式，需要先确定函数调用的位置。</p>
<p><strong>函数调用位置</strong><br>函数调用位置也就是函数在代码中被调用的位置<code>[函数名+()的形式]</code>，我们可以通过下面的示例代码来理解函数的调用位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;f1&quot;</span>);</span><br><span class="line">    <span class="comment">//当前的函数调用栈：f1</span></span><br><span class="line">    f2();   <span class="comment">//函数f2调用的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;f2&quot;</span>);</span><br><span class="line">    <span class="comment">//当前函数调用栈:f1 --&gt; f2</span></span><br><span class="line">    f3();   <span class="comment">//函数f3调用的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当前函数调用栈:f1--&gt;f2--&gt;f3</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;f3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">f1();       <span class="comment">//函数f1调用的位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-3-this绑定浅析"><a href="#1-3-this绑定浅析" class="headerlink" title="1.3 this绑定浅析"></a>1.3 this绑定浅析</h3><p><span style='border:1px solid #000'><strong>&nbsp; &nbsp;① 普通函数调用(默认绑定) &nbsp; &nbsp;</strong></span></p>
<p><code>普通函数调用</code>就是函数名后面直接更上调用运算符调用，这种情况下函数调用时应用了this的默认绑定，如果是在非严格模式下，该this指向全局对象window，如果是在严格模式下，不能将全局对象用于默认绑定，该this会绑定到undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量 t</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="number">123</span>;           <span class="comment">//所有全局变量自动成为全局对象的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>); <span class="comment">//foo</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);  <span class="comment">//this ---&gt; 全局对象window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.t);<span class="comment">//123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo();  <span class="comment">//非严格模式下:以普通函数方式调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;      <span class="comment">//作用域开启严格模式</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fn&quot;</span>); <span class="comment">//fn</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//this ---&gt;undefined</span></span><br><span class="line">    <span class="comment">//Uncaught TypeError: Cannot read property &#x27;t&#x27; of undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();  <span class="comment">//严格模式下:以普通函数方式调用</span></span><br></pre></td></tr></table></figure>
<img src='../../../../src/this_01.png'>

<p><span style='border:1px solid #000'><strong>&nbsp; &nbsp;② 对象方法调用(隐式绑定) &nbsp; &nbsp;</strong></span></p>
<p><code>对象方法调用</code>又称为隐式绑定，当函数引用有上下文对象的时候，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。需要注意的是，如果存在引用链，那么只有对象属性引用链中的最后一层在调用位置中起作用，下面我们通过一个代码片段来理解这种调用方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;wenidngding&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数调用，函数中的this默认绑定到全局对象，打印wendingding</span></span><br><span class="line">showName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;小猪佩奇&quot;</span>,</span><br><span class="line">    <span class="attr">showName</span>:showName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象方法调用，函数中的this绑定到当前的上下文对象obj,打印小猪佩奇</span></span><br><span class="line">obj.showName();</span><br></pre></td></tr></table></figure>
<p><strong>上下文对象</strong></p>
<p>上下文对象可以简单理解为函数调用时该函数的拥有者，或者引用当前函数的对象。</p>
<p><strong>this丢失的问题</strong></p>
<p>我们在确定this绑定问题的时候不能一根筋的把<code>该函数是否是对象的方法</code>作为判断的准则，而要抓住问题的本质，而且代码中可能存在this隐式绑定丢失的问题。外在的所有形式其实都不重要，最根本的就是看函数调用的时候，用的是什么方式？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面量方式创建对象，该对象拥有name属性和showName方法</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;小猪佩奇&quot;</span>,</span><br><span class="line">    <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用位置(001)</span></span><br><span class="line"><span class="comment">//对象方法调用，函数中的this绑定到当前的上下文对象obj1,打印小猪佩奇</span></span><br><span class="line">obj1.showName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//[1] 把obj.showName方法赋值给其他的对象</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">&quot;阿文&quot;</span>&#125;;</span><br><span class="line">obj2.show = obj1.showName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用位置(002)</span></span><br><span class="line"><span class="comment">//对象方法调用，函数中的this绑定到当前的上下文对象obj2,打印阿文</span></span><br><span class="line">obj2.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">//[2] 把obj.showName方法赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> fn = obj1.showName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用位置(003)</span></span><br><span class="line"><span class="comment">//普通函数调用，函数中的this指向全局对象，打印空字符串（window.name属性值是空字符串）</span></span><br><span class="line"><span class="comment">//注意：函数调用方式发生了改变，this丢失了</span></span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">//[3] 把obj.showName方法作为其他函数的参数（回调函数）来使用</span></span><br><span class="line"><span class="comment">//声明函数，该函数接收一个函数作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">callBack</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//调用位置(004)</span></span><br><span class="line">    <span class="comment">//普通函数调用，函数中的this指向全局对象，打印空字符串（window.name属性值是空字符串）</span></span><br><span class="line">    <span class="comment">//注意：函数调用方式发生了改变，this丢失了</span></span><br><span class="line">    callBack();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用位置(005) 此处不涉及this</span></span><br><span class="line">foo(obj1.showName);</span><br></pre></td></tr></table></figure>

<p><span style='color:#F55'><strong>➤ 思考：能否缩短对DOM操作相关的方法？</strong></span></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">&quot;demoID&quot;</span>)); <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明getById函数，该函数指向document.getElementById方法</span></span><br><span class="line"><span class="keyword">var</span> getById = <span class="built_in">document</span>.getElementById;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getById(<span class="string">&quot;demoID&quot;</span>));<span class="comment">//报错：Uncaught TypeError: Illegal invocation</span></span><br></pre></td></tr></table></figure>
<p><strong>代码说明</strong> 有的朋友可能尝试过像上面这样来写代码，发现通过这样简单的处理想要缩短DOM操作相关方法的方式是不可取的，为什么会报错？原因在于document.getElementById方法内部的实现依赖于this，而上面的代码<code>偷换了函数的调用方式，函数的调用方式由对象方法调用转变成了普通函数调用，this绑定的对象由document变成了window</code>。</p>
<p>怎么解决呢，可以尝试使用显式的绑定指定函数内的this，参考代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getById = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//显式的设置document.getElementById函数内部的this绑定到document对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById.apply(<span class="built_in">document</span>,<span class="built_in">arguments</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(getById(<span class="string">&quot;demoID&quot;</span>));  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>


<p><span style='border:1px solid #000'><strong>&nbsp; &nbsp;③ 构造函数调用(new绑定) &nbsp; &nbsp;</strong></span><br><code>构造函数方式调用</code>其实就是在调用函数的时候使用new关键字，这种调用方式主要用于创建指定构造函数对应的实例对象。</p>
<p><strong>构造函数</strong><br>构造函数就是普通的函数，本身和普通的函数没有任何区别，其实构造函数应该被称为<code>以构造方式调用的函数</code>，这样也许会更准确一些。因为在调用的时候总是以new关键字开头<code>[例如：new Person() ]</code>，所以我们把像Person这样的函数叫做构造函数。虽然构造函数和普通函数无异，但因为它们调用的直接目的完全不同，为了人为的区分它们，开发者总是约定构造函数的首字母大写。</p>
<p>当函数被以普通方式调用的时候，会完成实参向形参的赋值操作，继而自上而下的执行函数体中的代码，当构造函数被调用的时候，目的在于获得对应的实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个Person函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Perosn</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;姓名：&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 年龄：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用位置(001)</span></span><br><span class="line"><span class="comment">//构造函数方式调用(new绑定) Person函数内部的this指向新创建的实例对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Perosn(<span class="string">&quot;zs&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用位置(002)</span></span><br><span class="line"><span class="comment">//对象方法的方式调用(隐式绑定) show方法内部的this指向的是引用的对象，也就是p1</span></span><br><span class="line"><span class="comment">//打印：姓名：zs 年龄：18</span></span><br><span class="line">p1.show();</span><br></pre></td></tr></table></figure>
<p><strong>构造函数内部细节</strong></p>
<p>使用new以构造函数的方式来调用Person的时候，内部主要做以下操作</p>
<blockquote>
<p>① 创建空的Object类型的实例对象，假设为对象o<br>② 让函数内部的this指向新创建的实例对象o<br>③ 设置实例对象o的原型对象指向构造函数默认关联的原型对象<br>④ 在函数内通过this来添加属性和方法<br>⑤ 在最后默认把新创建的实例对象返回</p>
</blockquote>
<p><strong>总结</strong> <span style='color:#f55'>如果以构造函数方式调用，函数内部的this绑定给新创建出来的实例对象。</span></p>
<p><span style='border:1px solid #000'><strong>&nbsp; &nbsp;④ 函数上下文调用(显式绑定) &nbsp; &nbsp;</strong></span><br>在开发中我们可以通过call()或者是apply()方法来显式的给函数绑定指定的this，使用call或者是apply方法这种调用方式我们称为是函数上下文调用。</p>
<p>JavaScript语言中提供的绝大多数函数以及我们自己创建的所有函数都可以使用call和apply方法，这两个方法的作用几乎完全相同，只有传参的方式有细微的差别。</p>
<p><strong>call方法和apply方法的使用</strong></p>
<p>作用：借用对象的方法并显式绑定函数内的this。<br>语法：<code>对象.方法.call(绑定的对象，参数1，参数2...) | 对象.方法.apply(绑定的对象，[参数1，参数2...])</code></p>
<p>使用代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">    <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;姓名 &quot;</span> + <span class="built_in">this</span>.name,a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">&quot;ls&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用位置(001)</span></span><br><span class="line"><span class="comment">//以对象方法的方式调用函数，函数内部的this指向引用对象，也就是obj1</span></span><br><span class="line"><span class="comment">//打印结果为：姓名 zs 1 2</span></span><br><span class="line">obj1.showName(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用位置(002)</span></span><br><span class="line"><span class="comment">//obj2对象并不拥有showName方法，此处报错：obj2.showName is not a function</span></span><br><span class="line"><span class="comment">//obj2.showName();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用位置(003)</span></span><br><span class="line"><span class="comment">//函数上下文的方式(call)调用函数，函数内部的this绑定给第一个参数obj2</span></span><br><span class="line"><span class="comment">//打印结果为：姓名 ls 哈哈 嘿嘿</span></span><br><span class="line"><span class="comment">//第一个参数：obj2指定函数内this的绑定对象</span></span><br><span class="line"><span class="comment">//其它的参数：哈哈和嘿嘿这两个字符串是传递给showName函数的实参，调用时会赋值给函数的形参：a和b</span></span><br><span class="line">obj1.showName.call(obj2,<span class="string">&quot;哈哈&quot;</span>,<span class="string">&quot;嘿嘿&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用位置(004)</span></span><br><span class="line"><span class="comment">//函数上下文的方式(apply)调用函数，函数内部的this绑定给第一个参数obj2</span></span><br><span class="line"><span class="comment">//打印结果为：姓名 ls 呵呵 嘎嘎</span></span><br><span class="line"><span class="comment">//第一个参数：obj2指定函数内this的绑定对象</span></span><br><span class="line"><span class="comment">//其它的参数：呵呵和嘎嘎这两个字符串是传递给showName函数的实参，调用时会赋值给函数的形参：a和b</span></span><br><span class="line">obj1.showName.apply(obj2,[<span class="string">&quot;呵呵&quot;</span>,<span class="string">&quot;嘎嘎&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong> <span style='color:#f55'>如果以函数上下文的方式来调用，函数内部的this绑定call或者是apply方法的第一个参数，如果该参数不是对象类型那么会自动转换为对应的对象形式。</span></p>
<h3 id="1-4-this的注意事项"><a href="#1-4-this的注意事项" class="headerlink" title="1.4 this的注意事项"></a>1.4 this的注意事项</h3><p>我们已经介绍了一般情况下this绑定的问题，虽然上面的规则可以适用绝大多数的代码场景，但也并非总是百分百如此，也有例外。</p>
<p><span style='border:1px solid #000'><strong>&nbsp; &nbsp;例外的情况 ① &nbsp; &nbsp;</strong></span></p>
<p>在使用call或者apply方法的时候，<span style='color:#F55'>非严格模式下如果我们传递的参数是null或者是undefined，那么这些值在调用的时候其实会被忽略，this默认绑定的其实是全局对象。</span></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**[代码 01]**/</span></span><br><span class="line"><span class="comment">//声明全局变量用于测试</span></span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">&quot;测试的name&quot;</span>;</span><br><span class="line">   <span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">       <span class="attr">name</span>:<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">       <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&quot;姓名 &quot;</span> + <span class="built_in">this</span>.name,a, b);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注意：虽然此处以上下文的方式调用，但是因为传递的第一个参数是null,实际这里应用的是默认绑定规则</span></span><br><span class="line">   obj1.showName.call(<span class="literal">null</span>,<span class="number">1</span>,<span class="number">2</span>);       <span class="comment">//姓名 测试的name 1 2</span></span><br><span class="line">   obj1.showName.call(<span class="literal">undefined</span>,<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">//姓名 测试的name 1 2</span></span><br></pre></td></tr></table></figure>
<p>严格模式下，传递null或者是undefined作为call和apply方法的第一个参数，this的绑定和上下文调用保持一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**[代码 02]**/</span></span><br><span class="line"><span class="comment">//开启严格模式</span></span><br><span class="line"><span class="meta">   &quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//声明全局变量用于测试</span></span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       <span class="attr">name</span>:<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">       <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   obj.showName.call(<span class="literal">null</span>);        <span class="comment">//null</span></span><br><span class="line">   obj.showName.apply(<span class="literal">undefined</span>);  <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//建议的处理方式</span></span><br><span class="line">obj.showName.apply(<span class="built_in">Object</span>.create(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure>

<p><strong>建议</strong> 以前我们在以函数上下文方式来调用函数的时候，如果并不关心函数内部的this绑定，那么一般会传递null值或者undefined值。如果这样的话，在非严格模式下，函数内部的this默认绑定给全局对象并不安全，建议传递空对象[<code>可以使用Object.create(null)方式创建</code>]，这样函数操作会更安全而且代码可读性会更好。</p>
<p><span style='border:1px solid #000'><strong>&nbsp; &nbsp;例外的情况 ② &nbsp; &nbsp;</strong></span></p>
<p>ES6中推出了一种特殊的函数类型：箭头函数。箭头函数使用<code>=&gt;操作符</code>来定义，需要注意的是箭头函数内部的this绑定并不适用于既定的四种规则，this的绑定由外层作用域来决定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fn&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//fn函数中返回一个箭头函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">&quot;zs&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//fn以普通函数方式调用，fn中的this指向全局对象</span></span><br><span class="line"><span class="comment">//箭头函数中的this绑定由外部的词法作用域来决定,this指向window</span></span><br><span class="line">fn()();</span><br><span class="line"></span><br><span class="line"><span class="comment">//fn以函数上下文方式调用，fn中的this指向对象o</span></span><br><span class="line"><span class="comment">//箭头函数中的this绑定由外部的词法作用域来决定,this指向对象o</span></span><br><span class="line">fn.call(o)(); <span class="comment">//this指向&#123;name:&quot;zs&quot;&#125;对象</span></span><br></pre></td></tr></table></figure>

<p><span style='border:1px solid #000'><strong>&nbsp; &nbsp;例外的情况 ③ &nbsp; &nbsp;</strong></span></p>
<p>需要特别注意的是：在代码中我们可能会创建函数的“间接引用”，这种情况下调用函数会使用默认绑定规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = &#123;</span><br><span class="line">       <span class="attr">name</span>:<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">       <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> objB = &#123;<span class="attr">name</span>:<span class="string">&quot;ls&quot;</span>&#125;;</span><br><span class="line">   objA.showName();                <span class="comment">//对象方法调用，this指向objA 打印zs</span></span><br><span class="line"></span><br><span class="line">   (objB.showName = objA.showName)(); <span class="comment">//打印 空字符串</span></span><br></pre></td></tr></table></figure>
<p><strong>代码说明</strong> 我们重点看最后一行代码，赋值表达式<code>objB.showName = objA.showName</code>的返回值是目标函数的引用，这种<code>间接引用</code>调用方式符合普通函数调用的规则，this会被绑定给全局对象。最后一行代码，拆开来写的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = objB.showName = objA.showName;</span><br><span class="line">   f(); <span class="comment">//打印 空字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="1-5-this绑定总结"><a href="#1-5-this绑定总结" class="headerlink" title="1.5 this绑定总结"></a>1.5 this绑定总结</h3><p>当函数的调用位置确定后，我们可以顺序应用下面的四条规则来判断this的绑定对象</p>
<blockquote>
<p>① 是否由new调用？ 如果是，则绑定到构造函数新创建的实例对象身上。<br>② 是否由call或者apply调用？如果是，则绑定到第一个参数指定的对象身上。<br>③ 是有作为对象的方法调用？如果是，则绑定到这个引用的对象身上。<br>④ 默认普通函数调用，如果是严格模式则绑定到undefined，否则绑定到全局对象。</p>
</blockquote>
<img src='../../../../src/this_02.png'>

<img src='../../../../z.png' width="200px">

<hr>
<ul>
<li>Posted by 博客园·<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a> | <a target="_blank" rel="noopener" href="http://wendingding.com/">花田半亩</a></li>
<li>联系作者 简书·<a target="_blank" rel="noopener" href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&mod=TAB#place">Coder_文顶顶</a></li>
<li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/18/javaScript%E7%B3%BB%E5%88%97%20%5B07%5D-%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AE%A1%E6%97%B6%E5%99%A8/" class="prev">上一篇</a><a href="/2018/04/16/javaScript%E7%B3%BB%E5%88%97%20%5B05%5D-javaScript%E5%92%8CJSON/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://weibo.com/u/3800117445">文顶顶</a> &nbsp;☁ 全站字数统计 418.8k (字)</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>