<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> TypeScript系列 [06]-TypeScript语言特性(五) · 花田半亩</title><meta name="description" content="TypeScript系列 [06]-TypeScript语言特性(五) - 文顶顶"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/logo.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://weibo.com/u/3800117445/atom.xml" title="花田半亩"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="花田半亩" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文顶顶</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/wendingding/" target="_blank" class="nav-list-link">博客园</a></li><li class="nav-list-item"><a href="https://github.com/flowerField" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">TypeScript系列 [06]-TypeScript语言特性(五)</h1><div class="post-info">Jun 24, 2018<span class="post-count"></span> ✧ 字数统计:2.5k(字) &nbsp;&nbsp; ♨︎ 阅读时长:10(分钟)</div><div class="post-content"><blockquote>
<p>本文主要对TypeScript中的泛型进行展开介绍。主要包括以下内容</p>
<p>❏  泛型函数类型<br>❏  泛型接口（Interface）<br>❏  泛型类（Class）<br>❏  泛型约束</p>
</blockquote>
<h3 id="泛型函数的类型"><a href="#泛型函数的类型" class="headerlink" title="泛型函数的类型"></a>泛型函数的类型</h3><p>在<a target="_blank" rel="noopener" href="http://wendingding.com/2018/06/23/TypeScript%E7%B3%BB%E5%88%97%20[05]-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E5%9B%9B)">TypeScript语言特性</a>这篇文章中，我们已经介绍了什么是泛型函数，它跟普通函数还是有些区别的（泛型函数使用类型变量来占位，具体类型值由函数调用传参决定）。以前文章中介绍过TypeScript中的数据类型，以及可选的类型声明。虽然并没有必要（因为可以通过类型推导机制推导出来），但我们确实能够抽取出普通函数的具体类型。下面代码中demo函数的函数类型为：<code>(name:string,age:number) =&gt; string</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径 ../08-泛型函数/03-函数的类型.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[001] 函数的类型</span></span><br><span class="line"><span class="comment">//(1) 声明demo函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">name:string,age:number</span>):<span class="title">string</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;姓名:&quot;</span> +name + <span class="string">&quot;年龄:&quot;</span> + age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2) 把demo函数赋值给f</span></span><br><span class="line"><span class="keyword">let</span> f:<span class="function">(<span class="params">name:string,age:number</span>)=&gt;</span>string = demo;</span><br><span class="line"><span class="comment">//使用demo函数的调用签名</span></span><br><span class="line"><span class="comment">//let f:&#123;(name:string,age:number):string&#125; = demo;</span></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="string">&quot;zs&quot;</span>,<span class="number">18</span>));    <span class="comment">//姓名:zs年龄:18</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们花点时间研究，泛型函数的函数类型。其实<span style='color:#195'>泛型函数的类型与非泛型函数的类型本质上并没由什么不同，只是在最前面增加一个类型变量参数而已</span>。下面给出具体的代码示例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function demoT&lt;T&gt;(arg:T):T&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型函数demoT的类型为：&lt;T&gt;(arg:T) =&gt;T</span></span><br><span class="line">let f1 : &lt;T&gt;(arg:T) =&gt;T = demoT;</span><br><span class="line"><span class="comment">//使用带有调用签名的对象字面量来定义泛型函数</span></span><br><span class="line">let f2 : &#123;&lt;T&gt;(arg:T) :T&#125; = demoT;</span><br><span class="line"><span class="comment">//可以使用不同的泛型参数名（这里为X）</span></span><br><span class="line">let f3 : &lt;X&gt;(arg:X) =&gt;X = demoT;</span><br><span class="line"><span class="comment">//不使用类型声明</span></span><br><span class="line">let f4 = demoT;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">f1</span>(<span class="string">&quot;abc&quot;</span>));     <span class="comment">//abc</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">f2</span>(<span class="string">&quot;哈哈&quot;</span>));     <span class="comment">//哈哈</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">f3</span>(<span class="string">&quot;嘿嘿&quot;</span>));     <span class="comment">//嘿嘿</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">f4</span>(<span class="string">&quot;咕噜&quot;</span>));     <span class="comment">//咕噜</span></span><br></pre></td></tr></table></figure>
<div class='tip'>**提示** 泛型函数的类型声明可以使用不同的泛型参数，只要数量和使用方式一致即可。</div>

<h3 id="泛型接口（Interface）"><a href="#泛型接口（Interface）" class="headerlink" title="泛型接口（Interface）"></a>泛型接口（Interface）</h3><p><strong>接口（Interface）</strong><span style='color:#195'>指在面向对象编程语言中，不包含数据和逻辑但使用函数签名定义行为的抽象类型。</span></p>
<p>TypeScript提供了接口特性，TypeScript的接口可以定义数据和行为，也可以扩展其它接口或者类。</p>
<p>在传统面向对象编程范畴中，一个类可以被扩展为另外一个类，也可以实现一个或多个接口。实现某个接口可以被看做是签署了一份协议，接口相当于协议，当我们签署协议（实现接口）后，就必须遵守它的规则。</p>
<p><span style='color:red'>接口本身是抽象类型，其内容（规则）就是属性和方法的签名。</span></p>
<p>在前文中我们定义了泛型函数demoT，可以把demoT函数的签名抽取并定义接口GenericFn，下面给出示例代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径 ../08-泛型函数/04-泛型接口.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1) 声明泛型函数demoT</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoT</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2) 定义GenericFn接口</span></span><br><span class="line">interface GenericFn&#123;</span><br><span class="line">    &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn: GenericFn = demoT;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="string">&quot;哈哈&quot;</span>));  <span class="comment">//哈哈</span></span><br></pre></td></tr></table></figure>
<p>有时候，我们可能需要把泛型参数(T)抽取成为整个接口的参数，好处是抽取后我们能够清楚的知道使用的具体泛型类型是什么，且接口中的其它成员也能使用。当我们使用泛型接口的时候，传入一个类型参数来指定泛型类型即可，下面给出调整后的示例代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径 ../08-泛型函数/05-泛型接口02.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1) 声明泛型函数demoT</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoT</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2) 定义泛型接口</span></span><br><span class="line">interface GenericFn&lt;T&gt;&#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f1: GenericFn&lt;number&gt; = demoT;</span><br><span class="line"><span class="built_in">console</span>.log(f1(<span class="number">123</span>));       <span class="comment">//123</span></span><br><span class="line"><span class="comment">//报错：Argument of type &#x27;&quot;字符串&quot;&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span></span><br><span class="line"><span class="comment">//console.log(f1(&quot;字符串&quot;)); //错误的演示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f2: GenericFn&lt;string&gt; = demoT;</span><br><span class="line"><span class="built_in">console</span>.log(f2(<span class="string">&quot;字符串&quot;</span>)); <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="泛型类（Class）"><a href="#泛型类（Class）" class="headerlink" title="泛型类（Class）"></a>泛型类（Class）</h3><p>泛型特性可以应用在Class身上，具体的使用方式和接口差不多。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径 ../08-泛型函数/06-泛型类.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类(Class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//[1] 属性部分</span></span><br><span class="line">  <span class="attr">name</span>:T;</span><br><span class="line">  color:T;</span><br><span class="line">  <span class="comment">//[2] 方法部分</span></span><br><span class="line">  add:<span class="function">(<span class="params">a:T,b:T</span>)=&gt;</span>T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取实例对象p1</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person&lt;string&gt;();</span><br><span class="line">p1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错： TS2322: Type &#x27;123&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line"><span class="comment">//p1.name = 123;  错误的演示</span></span><br><span class="line">p1.color = <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">p1.add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p1);                      <span class="comment">//&#123;name:&quot;张三&quot;,color:&quot;Red&quot;,...&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.add(<span class="string">&quot;ABC&quot;</span>,<span class="string">&quot;-DEF&quot;</span>));    <span class="comment">//ABC-DEF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取实例对象p2</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person&lt;number&gt;();</span><br><span class="line">p2.name = <span class="number">0</span>;</span><br><span class="line">p2.color = <span class="number">1</span>;</span><br><span class="line">p2.add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p2.add(<span class="number">100</span>,<span class="number">200</span>));         <span class="comment">//300</span></span><br></pre></td></tr></table></figure>
<p>上面的代码提供了泛型类使用的简单示例，在<code>定义泛型类的时候，只需要直接把泛型类型放在类名(这里为Person)后面即可</code>，通过new调用类实例化的时候，以&lt;类型&gt;的方式传递，在Class中应用泛型可以帮助我们确认类中的很多属性都在使用相同的类型，且能够优化代码结构。</p>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>有时候，我们可能需要对泛型进行约束。下面的代码中我们声明了泛型函数fn，并在fn的函数体中执行<code>console.log(&quot;打印length值 = &quot; + arg.length);</code>意在打印参数的长度。这份代码在编译的时候会报错，因为无法确定函数调用时传入的参数一定拥有length属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径 ../08-泛型函数/02-泛型函数使用注意点.ts</span></span><br><span class="line"><span class="comment">//说明 该泛型函数使用类型变量T来表示接收参数和返回值的类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;打印length值 = &quot;</span> + arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错：error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;T&#x27;.</span></span><br><span class="line"><span class="built_in">console</span>.log(fn([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br></pre></td></tr></table></figure>
<p>其实相比于操作any所有类型的数据而言，在这里我们需要对参数类型进行限制，要求传入的参数能够拥有length属性，这种场景可以使用泛型约束。</p>
<p>理想中泛型函数fn的工作情况是：“只要传入的参数类型拥有指定的属性length，那么代码就应该正常执行。 为此，需要列出对于T的约束要求。下面，我们先定义一个接口来描述特定的约束条件。然后使用这个接口和<code>extends关键字</code>来实现泛型约束，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径 ../08-泛型函数/07-泛型约束.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[001] 定义用于描述约束条件的接口</span></span><br><span class="line">interface hasLengthP</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">length</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[002] 声明fn函数(应用了泛型约束)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">hasLengthP</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;打印length值 = &quot;</span> + arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[003] 调用测试</span></span><br><span class="line"><span class="built_in">console</span>.log(fn([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));   <span class="comment">//打印length值 = 3 [1,2,3];</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(&#123;<span class="attr">name</span>:<span class="string">&quot;zs&quot;</span>,<span class="attr">length</span>:<span class="number">1</span>&#125;)); <span class="comment">//打印length值 = 1 对象内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//说明：字符串会被转换为对象类型（基本包装类型）</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="string">&quot;测试&quot;</span>));    <span class="comment">//打印length值 = 2 测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//报错:error TS2345: Argument of type &#x27;123&#x27; is not assignable to parameter of type &#x27;hasLengthP&#x27;.</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">123</span>));   <span class="comment">//错误的演示</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的fn<code>泛型函数被定义了约束，因此不再是适用于任意类型的参数。</code>我们需要传入符合约束类型的值，传入的实参必须拥有length属性才能运行。</p>
<p><strong>泛型约束中使用多重类型</strong></p>
<p><strong>提示</strong> 当声明泛型约束的时候，我们只能够关联一种类型。但有时候，我们确实需要在泛型约束中使用多重类型，接下来我们研究下它的可能性和实现方式。</p>
<p>假设现在有一个泛型类型需要被约束，它只允许使用实现Interface_One和Interface_Two两个接口的类型，考虑应该如何实现？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径 ../08-泛型函数/08-泛型约束中使用多重类型01.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口：Interface_One和Interface_Two</span></span><br><span class="line">interface Interface_One&#123;</span><br><span class="line">  func_One();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Interface_Two&#123;</span><br><span class="line">  func_Two();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类（泛型约束为Interface_One,Interface_Two）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">classTest</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Interface_One</span>,<span class="title">Interface_Two</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="attr">propertyDemo</span>:T;</span><br><span class="line">  <span class="function"><span class="title">propertyDemoFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.propertyDemo.func_One();</span><br><span class="line">    <span class="built_in">this</span>.propertyDemo.func_Two();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可能会像这样来定义泛型约束，然而上面的代码在编译的时候会抛出错误，也就是说<span style='color:red'>我们不能在定义泛型约束的时候指定多个类型</span>（上面的代码中我们指定了Interface_One和Interface_Two两个类型），如果确实需要设计多重类型约束的泛型，可以通过把多重类型的接口转换为一个超接口来处理，下面给出示例代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径 ../08-泛型函数/09-泛型约束中使用多重类型02.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口：Interface_One和Interface_Two</span></span><br><span class="line">interface Interface_One&#123;</span><br><span class="line">  func_One();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Interface_Two&#123;</span><br><span class="line">  func_Two();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Interface_One和Interface_Two成为了超接口，它们是Interface_T的父接口</span></span><br><span class="line">interface Interface_T <span class="keyword">extends</span> Interface_One,Interface_Two&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">classTest</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Interface_T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="attr">propertyDemo</span>:T;</span><br><span class="line">  <span class="function"><span class="title">propertyDemoFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.propertyDemo.func_One();</span><br><span class="line">    <span class="built_in">this</span>.propertyDemo.func_Two();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">func_One</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;func_One&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">func_Two</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;func_Two&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取实例化对象classTestA</span></span><br><span class="line"><span class="keyword">let</span> classTestA = <span class="keyword">new</span> classTest();</span><br><span class="line">classTestA.propertyDemo = obj;</span><br><span class="line">classTestA.propertyDemoFunc();    <span class="comment">//func_One func_Two</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是错误的演示</span></span><br><span class="line"><span class="keyword">let</span> classTestB = <span class="keyword">new</span> classTest();</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错: Type &#x27;&#123; func_Two: () =&gt; void; &#125;&#x27; is not assignable to type &#x27;Interface_T&#x27;.</span></span><br><span class="line">classTestA.propertyDemo = &#123;</span><br><span class="line">  <span class="attr">func_Two</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;func_Two_XXXX&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>备注：该文章所有的示例代码均可以<a target="_blank" rel="noopener" href="https://github.com/flowerField/TypeScript-Demo">点击在Github托管仓库获取</a></p>
<hr>
<ul>
<li>Posted by 博客园·<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a> | <a target="_blank" rel="noopener" href="http://wendingding.com/">花田半亩</a></li>
<li>联系作者 简书·<a target="_blank" rel="noopener" href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&mod=TAB#place">Coder_文顶顶</a></li>
<li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/08/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B007%5D-%E4%BD%A0%E6%88%91%E7%9A%86%E5%87%A1%E4%BA%BA/" class="prev">上一篇</a><a href="/2018/06/23/TypeScript%E7%B3%BB%E5%88%97%20%5B05%5D-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E5%9B%9B)/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://weibo.com/u/3800117445">文顶顶</a> &nbsp;☁ 全站字数统计 418.8k (字)</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>