<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Node系列-http · 花田半亩</title><meta name="description" content="Node系列-http - 文顶顶"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/logo.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://weibo.com/u/3800117445/atom.xml" title="花田半亩"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="花田半亩" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文顶顶</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/wendingding/" target="_blank" class="nav-list-link">博客园</a></li><li class="nav-list-item"><a href="https://github.com/flowerField" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Node系列-http</h1><div class="post-info">Nov 28, 2018<span class="post-count"></span> ✧ 字数统计:3.7k(字) &nbsp;&nbsp; ♨︎ 阅读时长:15(分钟)</div><div class="post-content"><div class='tip'>本文对Node的内置模块http进行介绍，包括该模块的基本情况和简单使用。</div>

<h4 id="1-0-模块简介"><a href="#1-0-模块简介" class="headerlink" title="1.0 模块简介"></a>1.0 模块简介</h4><p><a href="">http</a>是Node的内置核心模块，包含了对HTTP处理的封装。</p>
<p>在Nodejs文件中可以直接在代码里通过<code>var http = require(&quot;http&quot;)</code>的方式来进行加载，该模块主要用来处理客户端HHTP请求以及服务器端的响应。在传统的HTTP服务器可能会使用<code>Apache</code>、<code>Nginx</code>或<code>IIS</code>之类的服务器端软件来处理，但在Node中并不需要这么复杂，我们使用它内置的http模块就可以非常方便的来构建服务器而且稳定可靠(<span style='color:#2c3e50'><strong>Node中的HTTP服务器继承自TCP服务器的<code>net</code>模块，它能够与多个客户端保持连接，因为其采用事件驱动的形式而并不会为每个连接都创建额外的线程，这保证了服务器的低内存占用率以实现高并发</strong></span>)。</p>
<p>我们可以非常方便的使用http模块来创建服务器或者是发起客户端网络请求。下面给代码示例：</p>
<blockquote>
<p><strong>创建Node服务器</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//备注：文件名为server.js</span></span><br><span class="line"><span class="comment">//001 引入Node内置的http模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//002 创建http服务器</span></span><br><span class="line"><span class="keyword">var</span> httpServer = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置响应头信息</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">        <span class="string">&quot;Content-type&quot;</span>:<span class="string">&quot;text/plain;charset=utf-8&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置具体的响应信息</span></span><br><span class="line">    response.write(<span class="string">&quot;Hi! Nice to meet u ...\n\n&quot;</span>);</span><br><span class="line">    response.write(<span class="string">&quot;这是响应的信息01---\n&quot;</span>);</span><br><span class="line">    response.write(<span class="string">&quot;这是响应的信息02---\n&quot;</span>);</span><br><span class="line">    response.write(<span class="string">&quot;这是响应的信息03---\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//响应结束(end)</span></span><br><span class="line">    response.end(<span class="string">&quot;这是响应的信息04---end&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//003 开启服务监听</span></span><br><span class="line">httpServer.listen(<span class="number">3000</span>,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开启服务监听：3000端口&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>运行这段代码(<code>在命令中通过node server.js运行</code>)，终端打印<code>开启服务监听：3000端口</code>信息。<br>在浏览器中访问<a href="">http://127.0.0.1:3000/</a>页面将显示下面的内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hi! Nice to meet u ...</span><br><span class="line"></span><br><span class="line">这是响应的信息01---</span><br><span class="line">这是响应的信息02---</span><br><span class="line">这是响应的信息03---</span><br><span class="line">这是响应的信息04---end</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>发起HTTP网络请求</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//001 导入http模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//002 声明变量(组织数据)</span></span><br><span class="line"><span class="keyword">var</span> responseData = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    <span class="string">&quot;host&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="comment">//请求的主机地址</span></span><br><span class="line">    <span class="string">&quot;port&quot;</span>:<span class="string">&quot;3000&quot;</span>,      <span class="comment">//请求的端口号</span></span><br><span class="line">    <span class="string">&quot;method&quot;</span>:<span class="string">&quot;get&quot;</span>      <span class="comment">//请求的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//003 创建并发起Http网络Get请求</span></span><br><span class="line">http.request(options,<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件监听：接收服务器端返回的数据(响应数据)</span></span><br><span class="line">    response.on(<span class="string">&quot;data&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        responseData += data;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件监听：如果接收完成那么就打印服务器返回的所有数据</span></span><br><span class="line">    response.on(<span class="string">&quot;end&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;服务器端响应完成，接收到的数据：&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(responseData);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).end();</span><br></pre></td></tr></table></figure>
<p>上面的代码通过http模块中的<code>http.request</code>方法创建并发起一个网络请求，并监听服务器的响应，当接收完服务器返回的响应数据之后打印并显示，给出执行情况。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wendingding:node wendingding$ node request.js </span><br><span class="line">服务器端响应完成，接收到的数据：</span><br><span class="line">Hi! Nice to meet u ...</span><br><span class="line"></span><br><span class="line">这是响应的信息01---</span><br><span class="line">这是响应的信息02---</span><br><span class="line">这是响应的信息03---</span><br><span class="line">这是响应的信息04---end</span><br></pre></td></tr></table></figure>
<h4 id="2-0-HTTP报文"><a href="#2-0-HTTP报文" class="headerlink" title="2.0 HTTP报文"></a>2.0 HTTP报文</h4><img src='../../../../src/node_http.png'>

<p>HTTP全称<code>HyperText Transfer Protocol</code>，即超文本传协议，属于应用层协议构建于TCP协议之上。</p>
<p>HTTP协议规定了客户端和服务器端之间应该如何进行通信。在<code>请求-响应模型</code>中，请求是客户端向服务器端索要数据或服务的过程，响应是服务器端把数据返回给客户端(为客户端提供服务)的过程，我们把它们在通信过程中的消息内容称为HTTP报文，下面简单介绍HTTP报文的结构(<a target="_blank" rel="noopener" href="http://wendingding.com/2018/01/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8CHTTP%E5%8D%8F%E8%AE%AE/">也可以参考这篇文章</a>)。</p>
<img src='../../../../src/node_http02.png'>

<blockquote>
<p><strong>HTTP请求报文结构</strong><br><strong>❏</strong> <code>请求行</code>   请求的方法和协议等信息<br><strong>❏</strong> <code>请求头</code>   客户端以及请求本身的描述信息<br><strong>❏</strong> <code>请求体</code>  提交给服务器端的参数(GET请求没有请求体信息)</p>
</blockquote>
<div></div>
>**HTTP响应报文结构**
> **❏** `状态行`   请求的状态码
> **❏** `响应头`   服务器端以及对响应本身的描述信息
> **❏** `响应体`   服务器返回给客户端的具体数据(`JSON/XML/Other`)。

<p>为了方便理解，这里我们使用命令行工具中的curl来发起网络请求并打印报文详情。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wendingding:node wendingding$ curl -v 127.0.0.1:3000</span><br><span class="line">* Rebuilt URL to: 127.0.0.1:3000/</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 3000 (<span class="comment">#0)</span></span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: 127.0.0.1:3000</span><br><span class="line">&gt; User-Agent: curl/7.49.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Content-type: text/plain;charset=utf-8</span><br><span class="line">&lt; Date: Thu, 29 Nov 2018 03:05:54 GMT</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; </span><br><span class="line">* Connection <span class="comment">#0 to host 127.0.0.1 left intact</span></span><br><span class="line">Hi ! Nice to meet u ~</span><br></pre></td></tr></table></figure>

<p><strong>备注</strong> HTTP协议采用的是请求-响应模式，基本上以一问一答的方式来实现服务，需要注意虽然HTTP服务基于TCP会话实现但其本身却没有会话的特点且HTTP协议传递的消息都是明文的。</p>
<h4 id="3-0-服务端核心方法"><a href="#3-0-服务端核心方法" class="headerlink" title="3.0 服务端核心方法"></a>3.0 服务端核心方法</h4><p><span style='border:1px solid #000;padding:5px 20px;'><strong>createServer方法</strong></span></p>
<p><strong>作用</strong> 创建HTTP服务器。<br><strong>语法</strong> <code>var server = http.createServer([ RequsetListener ]) </code><br><strong>参数</strong>  &nbsp;&nbsp;<span class='liX' style='width:150px'> RequsetListener</span>           可选的函数类型 | 用于指定当接收到客户端请求时执行的回调函数。<br><strong>展开</strong><br><span style='color:#607B8B'><strong>声明</strong></span><code>function RequsetListener(request,response)&#123;//...函数体&#125;</code><br><span style='color:#607B8B'><strong>形参</strong></span></p>
<ul>
<li><div class='liX'>request</div>   **http.IncomingMessage**对象 | 包含客户端请求信息。</li>
<li><div class='liX'>response</div>  **http.ServerResponse**对象&nbsp;&nbsp;&nbsp;  | 包含服务器响应相关的信息和方法。</li>
</ul>
<blockquote>
<p><span style='color:#607B8B'><strong>第一个参数 → request的核心成员</strong></span> </p>
</blockquote>
<p><span class='spaceXX backColor'>request.method</span> 请求方法。<br><span class='spaceXX backColor'>request.url</span> 请求的路径。<br><span class='spaceXX backColor'>request.headers</span> 请求头信息(对象)。<br><span class='spaceXX backColor'>request.rawHeaders</span> 接收到的原始请求头信息。<br><span class='spaceXX backColor'>request.httpVersion</span> 请求使用的HTTP协议版本。</p>
<blockquote>
<p><span style='color:#607B8B'><strong>第二个参数 → response的核心成员</strong></span> </p>
</blockquote>
<p><span class='spaceXX backColor '>response.finished</span> 响应是否已完成(默认<code>false</code>)。<br><span class='spaceXX backColor '>response.statusCode</span> 隐式响应头返回的状态码。<br><span class='spaceXX backColor '>response.statusMessage</span> 隐式响应头返回的状态信息。<br><span class='spaceXX backColor wMax'>response.getHeaders()</span> 获取所有响应头信息(浅拷贝)。<br><span class='spaceXX backColor wMax'>response.getHeader(name)</span> 读取指定的响应头信息。<br><span class='spaceXX backColor wMax'>response.getHeaderNames()</span> 获取响应头信息字段数组。<br><span class='spaceXX backColor wMax'>response.removeHeader(name)</span> 删除指定的响应头信息。<br><span class='spaceXX backColor wMax'>response.setHeader(name, value)</span> 设置响应头信息同<code>writeHead</code>。<br><span class='spaceXX backColor wMax'>response.setTimeout(msecs，[callback])</span> 设置 socket 的超时时间。<br><span class='spaceXX backColor wMax' style='background:#195;color:#fff'>response.write(chunk,[encoding],[callback])</span> 设置响应体数据。<br><span class='spaceXX backColor wMax' style='background:#195;color:#fff'>response.end([data],[encoding],[callback])</span> 设置响应体数据(结束)。<br><span class='spaceXX backColor wMax' style='background:#195;color:#fff'>response.writeHead(statusCode,[msg],[headers])</span> 设置响应头信息，优先级更高。</p>
<p>在<code>createServer</code>回调函数中两个参数分别是请求对象和响应对象，其中请求对象封装了对TCP连接的读操作，而响应对象则封装了对底层连接的写操作。这里做深入的展开：</p>
<p>当接收到客户端发起的网络请求后，HTTP请求报文的头部将通过模块内的<code>http_parser</code>进行解析，在解析的过程中，请求行(第一行:<code>GET / HTTP/1.1</code>)被分解为<code>method(GET)、url(/)、httpVersion(1.1)</code>属性，而请求头中的信息被保存到<code>headers</code>属性。</p>
<p>如果客户端请求中存在请求体(参数)，那么可以通过<code>url</code>模块的parse方法来解析路径获取参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//001 引入Node内置的http模块</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//002 创建http服务器</span></span><br><span class="line"><span class="keyword">var</span> httpServer = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用url模块把请求路径解析为对象</span></span><br><span class="line">    <span class="keyword">var</span> urlObj = url.parse(request.url,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印请求对象中的核心属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;method &quot;</span> + request.method); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;url &quot;</span> + request.url);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;query &quot;</span>,urlObj.query);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;httpVersion &quot;</span> + request.httpVersion); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;headers &quot;</span>,request.headers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取客户端提交的参数(请求体信息)</span></span><br><span class="line">     <span class="comment">//设置响应头信息</span></span><br><span class="line">     response.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">        <span class="string">&quot;Content-type&quot;</span>:<span class="string">&quot;text/plain;&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置响应信息</span></span><br><span class="line">    response.end(<span class="string">&quot;Hi! Nice to meet u ~&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;).listen(<span class="number">3000</span>,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开启服务监听：3000端口&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在命令行窗口中通过<code>node</code>命令来执行，下面列出打印结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">wendingding:node wendingding$ node server.js </span><br><span class="line">开启服务监听：3000端口</span><br><span class="line">method GET</span><br><span class="line">url    /?username=wendingding&amp;password=123</span><br><span class="line">query  &#123; username: <span class="string">&#x27;wendingding&#x27;</span>, password: <span class="string">&#x27;123&#x27;</span> &#125;</span><br><span class="line">httpVersion 1.1</span><br><span class="line"></span><br><span class="line">headers  </span><br><span class="line">&#123; <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;127.0.0.1:3000&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;cache-control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;upgrade-insecure-requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 AppleWebKit/537.36 Chrome/70.0.3538.102 Safari/537.36&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/apng,*/*;q=0.8&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;accept-encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;accept-language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9,en;q=0.8&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;cookie&#x27;</span>: <span class="string">&#x27;io=6oIwtImAumUxvtIvAACD&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过响应对象（<code>response</code>）来设置响应头信息以及构建响应体。</p>
<p>响应对象的<code>setHeader</code>方法和<code>writeHead</code>方法都能够设置响应头信息，它们的区别在于<span style='color:#195'><strong>只有当调用writeHead方法后，通过setHeader设置(可以调用N次)的信息才会被写入到连接(响应头)中</strong></span>。</p>
<p>响应对象的<code>write</code>方法和<code>end</code>方法均能够用来构建响应体信息，它们的区别在于<code>end</code>方法执行的时候会先调用内部的<code>write</code>方法来发送数据，然后发送信号告知服务器本次响应结束，响应结束后，HTTP服务器可能会将当前连接直接用于后面的请求或者是关闭网络连接。</p>
<p><strong>注意点</strong> 设置响应头信息需要在write和end方法前，响应结束后应该调用end方法结束请求，否则客户端将一直处于等待状态。</p>
<p><span style='border:1px solid #000;padding:5px 20px;'><strong>listen方法</strong></span></p>
<p><strong>作用</strong> 开启服务器监听。<br><strong>语法</strong> <code>http.createServer().listen(port,[host],[backlog],[callBack]) </code><br><strong>参数</strong>  </p>
<ul>
<li><span class='liX' style='width:100px'> port</span> 指定需要监听的端口号。</li>
<li><span class='liX' style='width:100px'> host</span> 指定需要监听的地址，省略表示监听所有的客户端连接。</li>
<li><span class='liX' style='width:100px'> backlog</span> 指定允许客户端连接的最大数量，默认511。</li>
<li><span class='liX' style='width:100px'> callBack</span> 指定<code>listening</code>事件触发的回调函数(没有任何参数)。</li>
</ul>
<p><span style='border:1px solid #000;padding:5px 20px;'><strong>writeHead方法</strong></span></p>
<p><strong>作用</strong> 设置响应头信息。<br><strong>语法</strong> <code>response.writeHead(statusCode,[msg],[headers])</code><br><strong>参数</strong>  </p>
<ul>
<li><span class='liX' style='width:100px'> statusCode</span> 响应状态吗，譬如200。</li>
<li><span class='liX' style='width:100px'> msg</span> 响应状态信息，譬如<code>Not found</code>。</li>
<li><span class='liX' style='width:100px'> headers</span> 具体的响应头信息(<code>以key:value</code>组织成对象)。</li>
</ul>
<h4 id="4-0-客户端核心方法"><a href="#4-0-客户端核心方法" class="headerlink" title="4.0 客户端核心方法"></a>4.0 客户端核心方法</h4><p>HTTP客户端的处理方式同服务器端的处理方式几乎一致，不同在于服务器端主要设置响应头和构建响应体信息，而客户端主要设置请求信息(请求头和请求体)，它本身其实就是服务器端服务模型的另一部分。我们可以使用<code>request</code>方法来发起一个网络请求，或者也可以直接使用<code>get</code>方法来快速的发起一个get请求，其结构同Ajax异步发送网络请求基本一致。</p>
<p><span style='border:1px solid #000;padding:5px 20px;'><strong>request方法</strong></span></p>
<p><strong>作用</strong> 创建并发送网络请求。<br><strong>语法</strong> <code>http.request(url,[ options ],[ callBack ]) | http.request(options,[ callBack ])</code><br><strong>参数</strong> </p>
<ul>
<li><span class='liX' style='width:100px'> options</span> 请求的配置对象。</li>
<li><span class='liX' style='width:100px'> callBack</span> 获取服务器端响应时执行的函数，参数为响应对象。</li>
</ul>
<blockquote>
<p><strong>Options主要配置项</strong><br><strong>❏</strong> <span class='liYY' >host</span>        服务器的域名或IP地址，默认为<code>localhost</code>。<br><strong>❏</strong> <span class='liYY'>hostname</span>    服务器的名称。<br><strong>❏</strong> <span class='liYY'>port</span>         服务器端口，默认为<code>80</code>。<br><strong>❏</strong> <span class='liYY'>method</span>       请求方法，默认为<code>GET</code>。<br><strong>❏</strong> <span class='liYY'>path</span>         请求路径，默认为<code>/</code>。<br><strong>❏</strong> <span class='liYY'>agent</span>      用于指定HTTP代理。<br><strong>❏</strong> <span class='liYY'>headers</span>      用于指定客户端的请求头信息。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//001 导入http模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//002 创建并发起Http网络Get请求</span></span><br><span class="line"><span class="keyword">var</span> httpRequest = http.request(&#123;</span><br><span class="line">    <span class="string">&quot;host&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="comment">//请求的主机地址</span></span><br><span class="line">    <span class="string">&quot;port&quot;</span>:<span class="string">&quot;3000&quot;</span>,      <span class="comment">//请求的端口号</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取响应对象中的信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;statusCode &quot;</span>,res.statusCode);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;响应头信息 &quot;</span>,res.headers);</span><br><span class="line">    res.on(<span class="string">&quot;data&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;响应体数据 ==&gt; &quot;</span>,data.toString(<span class="string">&quot;utf8&quot;</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//004 结束请求</span></span><br><span class="line">httpRequest.end();</span><br></pre></td></tr></table></figure>
<p>在命令行工具中通过<code>node</code>命令来发起网络请求，并打印服务器返回的响应信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wendingding:node wendingding$ node request.js </span><br><span class="line">statusCode  200</span><br><span class="line">响应头信息  &#123; <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/plain;&#x27;</span>,</span><br><span class="line">  date: <span class="string">&#x27;Thu, 29 Nov 2018 07:53:36 GMT&#x27;</span>,</span><br><span class="line">  connection: <span class="string">&#x27;close&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;transfer-encoding&#x27;</span>: <span class="string">&#x27;chunked&#x27;</span> &#125;</span><br><span class="line">响应体数据 ==&gt;  Hi! Nice to meet u ~</span><br></pre></td></tr></table></figure>

<h4 id="5-0-事件"><a href="#5-0-事件" class="headerlink" title="5.0 事件"></a>5.0 事件</h4><p>为了方便应用层的使用，HTTP服务器和客户端都抽象了一些事件，这些事件都能够使用<code>on</code>方法来进行监听，不同的事件对应请求或响应的不同阶段。</p>
<blockquote>
<p><strong>HTTP服务事件</strong> </p>
</blockquote>
<p><span class='prop'><strong>connection</strong></span>  当客户端和服务器建立连接的时候触发。<br><span class='prop' style='background:#e96900;color:#fff'><strong>request</strong></span>  在请求发送到服务器端并解析出请求头后触发。<br><span class='prop'><strong>close</strong></span>  当调用close方法停止接受新连接已有连接都断开的时候触发。<br><span class='prop'><strong>connect</strong></span>  当客户端发起CONNECT请求(代理)的时候触发。<br><span class='prop'><strong>timeout</strong></span>  当服务器超时的时候触发(可以通过<code>server.setTimeOut</code>来设置)。</p>
<blockquote>
<p><strong>HTTP请求事件</strong> </p>
</blockquote>
<p><span class='spaceX' ><strong>timeout</strong></span> 当客户端请求超时的触发。<br><span class='spaceX' style='background:#195;color:#fff'><strong>abort</strong></span>  当请求已被客户端终止时触发。<br><span class='spaceX' style='background:#195;color:#fff'><strong>response</strong></span>  当接收到服务器响应的时候触发。<br><span class='spaceX'><strong>socket</strong></span>  当底层连接池中建立的连接分配给当前请丢对象时触发。<br><span class='spaceX'><strong>connect</strong></span>  当客户端发起CONNECT请求时，如果服务器端返回200则触发。</p>
<p>http模块中事件的监听和触发比较恶心，这里简单在下面列出具体的情况。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">如果请求成功，则以下事件会被依次触发：</span><br><span class="line">    ① &#x27;socket&#x27; 事件。</span><br><span class="line">    ② &#x27;response&#x27; 事件。</span><br><span class="line">        [1] res 对象的 &#x27;data&#x27; 事件（多次，若响应体为空，则不触发）。</span><br><span class="line">        [2] res 对象的 &#x27;end&#x27; 事件。</span><br><span class="line">    ③ &#x27;close&#x27; 事件。</span><br><span class="line"></span><br><span class="line">如果连接出错，则以下事件会被依次触发：</span><br><span class="line">    ① &#x27;socket&#x27; 事件。</span><br><span class="line">    ② &#x27;error&#x27;  事件。</span><br><span class="line">    ③ &#x27;close&#x27;  事件。</span><br><span class="line"></span><br><span class="line">如果连接成功之前调用 req.abort()，则以下事件会被依次触发：</span><br><span class="line">    ① &#x27;socket&#x27; 事件。</span><br><span class="line">        (此时调用 req.abort())</span><br><span class="line">    ② &#x27;abort&#x27; 事件。</span><br><span class="line">    ③ &#x27;close&#x27; 事件。</span><br><span class="line">    ④ &#x27;error&#x27; 事件并带上错误信息 &#x27;Error: socket hang up&#x27; 和错误码 &#x27;ECONNRESET&#x27;。</span><br><span class="line"></span><br><span class="line">如果响应接收到之后调用 req.abort()，则以下事件会被依次触发：</span><br><span class="line">    ① &#x27;socket&#x27; 事件。</span><br><span class="line">    ② &#x27;response&#x27; 事件。</span><br><span class="line">        [1] res 对象的 &#x27;data&#x27; 事件（多次）。</span><br><span class="line">        (此时调用 req.abort())</span><br><span class="line">    ③ &#x27;abort&#x27; 事件。</span><br><span class="line">    ④ &#x27;close&#x27; 事件。</span><br><span class="line">        res 对象的 &#x27;aborted&#x27; 事件。</span><br><span class="line">        res 对象的 &#x27;end&#x27; 事件。</span><br><span class="line">        res 对象的 &#x27;close&#x27; 事件。</span><br></pre></td></tr></table></figure>

<img src='../../../../z.png' width="200px">

<hr>
<ul>
<li>Posted by 博客园·<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a> | <a target="_blank" rel="noopener" href="http://wendingding.com/">花田半亩</a></li>
<li>联系作者 简书·<a target="_blank" rel="noopener" href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&mod=TAB#place">Coder_文顶顶</a></li>
<li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/12/01/Node%E7%B3%BB%E5%88%97-fs/" class="prev">上一篇</a><a href="/2018/11/27/Node%E7%B3%BB%E5%88%97-PRPL/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://weibo.com/u/3800117445">文顶顶</a> &nbsp;☁ 全站字数统计 420.5k (字)</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>