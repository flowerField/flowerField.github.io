<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 前端工程化系列[06] Yeoman脚手架核心机制 · 花田半亩</title><meta name="description" content="前端工程化系列[06] Yeoman脚手架核心机制 - 文顶顶"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/logo.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://weibo.com/u/3800117445/atom.xml" title="花田半亩"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="花田半亩" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/%E9%B2%B8%E9%B1%BC.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文顶顶</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/wendingding/" target="_blank" class="nav-list-link">博客园</a></li><li class="nav-list-item"><a href="https://github.com/flowerField" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">前端工程化系列[06] Yeoman脚手架核心机制</h1><div class="post-info">May 26, 2018<span class="post-count"></span> ✧ 字数统计:5.3k(字) &nbsp;&nbsp; ♨︎ 阅读时长:19(分钟)</div><div class="post-content"><img src='../../../../src/yeoman02.png'>

<div class='tip'>在[前端工程化系列[05] Yeoman脚手架使用入门](http://wendingding.com/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[05]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/)这边文章中，对Yeoman的使用做了简单的入门介绍，这篇文章我们将接着探讨Yeoman这个脚手架工具内部的核心机制，主要包括以下内容</div>

<blockquote>
<p>❏  Yeoman脚手架工具的价值讨论<br>❏  generator[<code>生成器</code>]的内部结构<br>❏  generator[<code>生成器</code>]的项目模板<br>❏  Yeoman脚手架工具的核心运转机制<br>❏  Yeoman 的主要组装流程</p>
</blockquote>
<h3 id="Yeoman这样的脚手架工具解决了什么问题？"><a href="#Yeoman这样的脚手架工具解决了什么问题？" class="headerlink" title="Yeoman这样的脚手架工具解决了什么问题？"></a>Yeoman这样的脚手架工具解决了什么问题？</h3><p>所有新事物都不是凭空产生的，它们的出现总有某些内在的驱动力。一项新技术，一个新工具的出现更是如此。不知道从什么时候开始起，我接触新事物新技术以及某些工具的时候，总愿意多花点时间想一想它出现的原因是什么？因为时间、精力等等这些东西都很宝贵，IT从业人员对这些资源尤其敏感，所以新技术或者新工具的出现我认为有几种情况：</p>
<ul>
<li>已有的技术或工具存在缺陷，作者们靠自己的才学推出**<code>更完美的替代方案</code>**</li>
<li>已有的技术或工具无法解决既定的需求，作者们探索出**<code>解决问题的技术方案</code>**</li>
<li>纯粹闲的蛋疼（这种情况一般比较少见）</li>
</ul>
<p>现在，我们来研究下Yeoman的价值，或者说<span style='color:#195'>Yeoman出现的意义是什么？Yeoman的出现解决了什么样的问题？</span></p>
<p>我们假设有这样的开发场景：公司的开发团队，基于某些特定的技术栈已经完成了项目A的开发和上线等工作，项目A的基本情况如下</p>
<blockquote>
<p>技术栈：JavaScript + HTML + CSS + Bootstrap + jQuery<br>工作流：npm（包管理工具） + bower（下载器） +  grunt<br>版本管理工具：Git</p>
</blockquote>
<p>项目整体目录结构（简化后）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Gruntfile.js</span><br><span class="line">├── bower.json</span><br><span class="line">├── node_modules</span><br><span class="line">│   ├── abbrev</span><br><span class="line">···</span><br><span class="line">│   └── xtend</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── build</span><br><span class="line">│   ├── css</span><br><span class="line">│   │   └── style.min.css</span><br><span class="line">│   └── js</span><br><span class="line">│       ├── index.js</span><br><span class="line">│       └── index.min.js</span><br><span class="line">├── dist</span><br><span class="line">└── src</span><br><span class="line">    ├── css</span><br><span class="line">    │   └── style.css</span><br><span class="line">    ├── index.html</span><br><span class="line">    ├── js</span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── libs</span><br><span class="line">    │   ├── bootstrap</span><br><span class="line">    │   └── jquery</span><br><span class="line">    └── template</span><br></pre></td></tr></table></figure>

<div class='tip'>说明：上面的目录中src为代码的工作目录，bulid为构建后目录，dist为发布目录。</div>

<p>因为项目A已经上线发布，现在公司要求着手开展新的项目B，经过需求评审和技术选型后，新项目B采用的工作流和项目A保持一致，技术栈在原有的基础上尝试使用TypeScript来处理脚本部分引入Vue框架，其它部分保持不变。我们发现项目A和项目B它们的结构基本上是一致的（比如项目的目录就够，都需要拥有Gruntfile.js和package.json等文件），但是有些部分又不太一样，比如package.json文件中的项目名称、开发依赖等。</p>
<p>这个时候，我们在对项目B进行初始化的方式可以尝试以下操作方式：</p>
<ul>
<li><span style='color:red'>方案①</span> <strong>从0开始创建目录结构，集成工作流配置开发环境</strong></li>
<li><span style='color:red'>方案②</span> <strong>从项目A中拷贝目录结构和固定文件，对于不同的部分一个个修改</strong></li>
</ul>
<p>如果我们采用方案① 你会发现这个过程你在初始化项目A的时候就已经做过了，是重复性的工作，毫无技术含量但是又费时费力。<br>如果我们采用方案② 你会发现要修改的文件有些多，每个文件要改的字段也比较多，而且容易遗漏总是调不通会出现各种问题，心烦意乱。</p>
<p>如果你会使用Yeoman脚手架工具的话，那么对于上面的开发场景你就会多一个方案③，在使用方案③来初始化项目B的时候，你只需要动动手指在终端中输入<code>$ yo 生成器名称</code>再使用交互方式简单配置某些特定值，初始化的工作就完成了。这就是Yeoman的价值所在，初始化项目的时候你不必再把自己沉入到琐碎重复无技术成长的费力工作中，也不必总是像个机器人般进入到拷贝-粘贴-修改这样无止境的循环中。<span style='color:#0b0'>脚手架工具是那么的简单直接和高效，你甚至可以省出点加班的时间来看世界杯了 : ) </span></p>
<p>我知道有一些杠精要出来喷了。<code>“解决这种初始化问题不用搞的这么复杂，我完全可以把项目结构和固定不变的部分抽取出来托管到gitHub仓库，要初始化项目的时候 $ git clone一下不就好了吗？”</code></p>
<p>说的很有道理，但是clone下来的仓库虽然结构和必要文件已经准备好了，但很多文件是不是还得修改？那你会顶回来<code>“难道使用Yeoman初始化就不需要修改了吗？” </code>当然也要修改，不过就算是修改那改起来也很有趣味还So快！<div class='tip'>Yeoman使用交互式的方式来对项目文件中需要灵活处理的部分进行配置，这部分内容我们称为组装指令，具体再文章的后面会进行讲解。</div>另外，如果新项目的整体结构以及技术选型和已有的项目很不一样，那你抽取后交由git管理的仓库就没用了，因为八字不合啊。使用Yeoman就没用这样的顾虑，在<a target="_blank" rel="noopener" href="http://yeoman.io/generators/">Yeoman-generator列表</a>有好几千现成的generator供你选择，总有一款适合你！！！</p>
<p> 我要求太太…太高，实在谁也看不上？没关系，generator这家伙还可以私人订制，你完全可以根据自己的需求来定制需要的generator，你一高兴甚至还能把它发布到社区造福全人类。</p>
<h3 id="Yeoman-generator的内部结构"><a href="#Yeoman-generator的内部结构" class="headerlink" title="Yeoman-generator的内部结构"></a>Yeoman-generator的内部结构</h3><p>搞清楚 generator的价值所在和应用场景之后，我们就可以开始谈论generator相关的话题了，前面介绍过Yeoman脚手架工具的作用是帮助我们依据特定的技术栈需求来初始化项目，在安装了yo工具之后，只需要在终端中使用类似<code>$ yo generator--xx</code>的命令先安装对应的generator然后再<code>$ yo xx</code>搭建即可。至于如何找到匹配当前技术选型的generator，可以去官网的generator列表搜索，这些生成器中有很大一部分来自于对应框架的作者或者Yeoman官方团队，质量有保证且更新很及时。当然，我们也可以创建自己的generator并发布。关于如何创建自己的generator，我们放到另一篇文章<a target="_blank" rel="noopener" href="http://wendingding.com/2018/06/14/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[07]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6generator%E5%88%9B%E5%BB%BA/">Yeoman脚手架生成器创建</a>来解决。</p>
<p>简单说Yeoman做的工作其实就是根据当前的生成器（generator）来复制固定的项目模板文件到新项目中，而新项目中的某些文件需要配置，这部分工作由安装时候的交互式指令来完成（相当于传递参数给模板文件）。</p>
<div class='tip'>需要注意的是，Yeoman的设计仅仅只提供了一小部分核心的API，而真正繁重的初始化工作是交给每个具体的generator来完成的。</div>

<p>generator主要由**<code>组装指令</code><strong>和</strong><code>项目模板</code>**两部分组成。</p>
<img src='../../../../src/yeoman03.png' width='600px'>

<p><strong>组装指令</strong></p>
<p>Yeoman generator中的generators/app/index.js文件是整个生成器的核心部分，该文件用于告知Yeoman该如何来组织并搭建项目，我们可以在该文件中设置初始化项目时必要的安装提示和选项来让用户选择，以及每个文件应该如何复制和修改，是否需要加载依赖和Node包等内容。</p>
<p><strong>项目模板</strong></p>
<p>项目模板包括初始化项目需要的所有必须文件。这些文件又可以简单的划分为**<code>固定文件</code><strong>、</strong><code>灵活文件</code><strong>、</strong><code>可选文件</code><strong>和</strong><code>依赖文件</code><strong>。所谓<code>固定文件</code>就是在每个初始项目中都一模一样的文件，譬如index.js、style.css等文件，在具体处理的时候这些文件只需要简单复制即可。<code>灵活文件</code>指的是那些需要根据用户选择来做简单修改然后才能复制的文件，譬如index.html文件（title等信息需根据用户输入来指定）。对于<code>可选文件</code>来说，它们并不是必须的，譬如某些基础框架有的项目中需要，有的项目中也许并不需要，这部分文件的处理方式需要</strong>交给用户来决定**。</p>
<h3 id="项目模板文件的类别"><a href="#项目模板文件的类别" class="headerlink" title="项目模板文件的类别"></a>项目模板文件的类别</h3><p>前面已经介绍过了Yeoman生成器的组成部分主要是组装指令和项目模板。对于整个Yeman脚手架工具来说，项目模板这部分就相当于是搭建脚手架需要用到的原材料，而组装指令用来决定和控制所有的具体行动是什么。</p>
<p>现在我们开始深入的来讨论项目模板这部分内容，需要先明白的是<code>“能够满足所有需求的万能的项目模板是不存在的”</code>。因为这世界上每个项目组，每个产品甚至每个人的需求(要求)都各有不同。所以，在实践中你必须要对当前项目的需求和采用的技术栈有深入的理解，这样你才能知道目标项目的目录结构会是什么样的? 哪些文件是必不可少的。</p>
<p>如果你的项目和采用的技术栈比较大众化，那么搜索一个合适的generator基本就能满足需求，拿来主义即可。如果你的项目不管结构还是所采用的技术看上去都那么的非凡和特别，那么就多花一点点时间创建个自己的generator吧，如果你需要处理多个这样的项目，那就更应该了。在创建或者理解generator的时候，我们可以根据前面对项目模板文件的划分情况来区别对待不同的文件。</p>
<p><strong>固定文件</strong></p>
<p><span style='color:#195'>固定文件是在每个项目中初始内容都一样的必要文件。</span></p>
<p>比如我们可能总是会把代码的结构划分为<code>src</code>、<code>build</code>和<code>dist</code>三个目录，在src目录下面拥有js、css和lib文件目录，index.js和style.css等文件。这些文件都是必要的，刚开始的时候可能是空的或者只有几行简单的代码。这些文件的特点是，在使用组装指令操作(通常是复制-移动)这些文件的时候，不需要对它们进行任何的修改。</p>
<p><strong>灵活文件</strong></p>
<p><span style='color:#195'>灵活文件和固定文件差不多，也是初始化项目所必须的，但不同的项目中这些文件的内容也会稍有不同</span>，这些不同之处可能很细微(比如仅仅是名字、协议这些)，也可能差异巨大。比如，我们常用的构建工作流中的<code>bower.json</code>和<code>package.json</code>文件，它们是必不可少的，但是它们都需要当前项目的项目名称和协议等信息才能正常工作。像这样的灵活文件还有index.html，在这个文件中的title标签中应该使用当前项目的名称。</p>
<p>灵活文件中的部分内容需要在安装该生成器的时候，由用户交互式配置输入的信息来进行设定。</p>
<p><strong>可选文件</strong></p>
<p><span style='color:#195'>可选文件并不是搭建初始化项目时所必须的文件，如果没有那么没关系，如果有那似乎更好。</span>这些一般在用户交互式配置的时候，以是否题的方式交由用户决定，譬如是否使用less 是否安装Bootstrap等。</p>
<p><strong>依赖文件</strong></p>
<p><span style='color:#195'>依赖文件指的是某些常用的框架、插件或者是Node模块</span>，这些文件并不需要你在项目模板文件中提供，然后通过组装指令去一个个复制。因为基本上成熟的项目中都会使用既定的工作流(主要包括依赖和包的下载、项目的自动化构建等)，所以我们完全只需要在<code>package.json</code>或者<code>bower.json</code>等文件中设置好依赖即可，然后在组装指令的相关代码中通过<code>this.installDependencies（）</code>类似的代码来调用npm或者是bower执行install命令即可。</p>
<h3 id="Yeoman脚手架运转的核心机制"><a href="#Yeoman脚手架运转的核心机制" class="headerlink" title="Yeoman脚手架运转的核心机制"></a>Yeoman脚手架运转的核心机制</h3><p>当您为项目准备好(搜索或自己创建)合适的generator之后，就可以用它们来搭建项目了。generator的执行需要在终端中使用yo命令来操作。yo是Yeoman的核心命令，主要用来连接生成器和项目结构。<span style='color:#f25'>我们可以把yo命令理解为generator的执行器，它知道怎么找到对应的generator，也知道该如何执行它们。</div></p>
<div class='tip'>注意：yo基于NodeJS且需要在任何文件目录中使用，所以在安装yo命令的时候应该使用-g来进行全局安装。安装过程请参考：[Yeoman脚手架使用入门](http://wendingding.com/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[05]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/)。</div>

<p>在使用yo命令行工具和生成器来初始化项目之前，需要先把指定的生成器(generator)下载安装到本地（如果是自己创建的生成器，那么可以通过<code>$ npm link</code>命令以软连接的方式生成一个全局的npm包，我的是mac OSX系统，生成的npm包会保存在/usr/local/lib/node_modules/路径，如果使用的是别人发布的generator，那么请使用<code>$ npm install -g generator-xxx</code>的方式来安装）。</p>
<p>这里需要注意的是<code>yo命令行工具主要负责前期工作，在使用的时候它主要检查当前安装的generator有哪些，指定的generator是否能够正常工作，如果能，那么它就会调用generator的组装指令，把剩下部分的工作交接给generator来完成。generator接管项目的组装流程之后，会按app/index.js中的要求来处理文件的复制等工作</code>。</p>
<p>下面给出脚手架工具初始化项目时的核心流程。<br><img src='../../../../src/yeoman04.png'></p>
<p>这里对yo的主要命令进行简单说明</p>
<p><code>$ yo</code> 执行该命令的时候，yo会搜索并列出所有本地可用的生成器<br><code>$ yo 生成器名称</code> 比如对于<code>generator-typescript</code>生成器，那么执行的命令就是<code>$ yo typescript</code>。该命令会先检查<code>enerator-typescript</code>生成器是否可用。如果可用，那么就接着以 ①交互式配置 ② 写入文件 ③ 下载安装依赖的顺序来执行组装指令。</p>
<h3 id="Yeoman的主要组装流程"><a href="#Yeoman的主要组装流程" class="headerlink" title="Yeoman的主要组装流程"></a>Yeoman的主要组装流程</h3><p>组装指令是用来让Yeoman创建项目所需文件的一系列具体的命令(代码)。典型的组装流程分为三个步骤：</p>
<img src='../../../../src/yeoman05.png'>

<blockquote>
<p><strong>① 交互式配置</strong>。这个步骤通过向用户提问或直接输入配置信息来完成模板传参。<br><strong>② 写入文件</strong>。把项目模板中的指定文件复制到新项目的指定目录中。<br><strong>③ 安装依赖</strong>。下载并安装所有保存在bower.json和package.json文件中的依赖和Node模块。</p>
</blockquote>
<p><strong>① 交互式配置</strong></p>
<p>Yeoman在执行生成器的时候，首先会执行安装提示以交互式的方式来询问用户，目的是为了获取生成器所需要的一些参数，比如项目的名称、作者、使用的开原协议以及是否安装和使用某些组件等。</p>
<p>这部分功能，需要使用到inquirer包，这个包的作用是生成选项来让用户选择。下面给出代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">prompting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">const</span> prompts = [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>    : <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>    : <span class="string">&#x27;appName&#x27;</span>,</span><br><span class="line">        <span class="attr">message</span> : <span class="string">&#x27;请输入项目名称:&#x27;</span>,</span><br><span class="line">        <span class="attr">default</span> : <span class="built_in">this</span>.appname        <span class="comment">//appname是内置对象，代表工程名，这里就是ys</span></span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">type</span>    : <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">       <span class="attr">name</span>    : <span class="string">&#x27;appAuthor&#x27;</span>,</span><br><span class="line">       <span class="attr">message</span> : <span class="string">&#x27;请输入作者姓名:&#x27;</span>,</span><br><span class="line">       <span class="attr">default</span> : <span class="string">&#x27;文顶顶&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;appLicense&#x27;</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;请选择使用的license:&#x27;</span>,</span><br><span class="line">        <span class="attr">choices</span>: [<span class="string">&#x27;MIT&#x27;</span>, <span class="string">&#x27;ISC&#x27;</span>, <span class="string">&#x27;Apache-2.0&#x27;</span>, <span class="string">&#x27;AGPL-3.0&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>    : <span class="string">&#x27;confirm&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>    : <span class="string">&#x27;isIncludeBootstrap&#x27;</span>,</span><br><span class="line">        <span class="attr">message</span> : <span class="string">&#x27;是否需要使用bootStrap框架？&#x27;</span>,</span><br><span class="line">        <span class="attr">default</span> : <span class="literal">false</span></span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.prompt(prompts).then(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// To access props later use this.props.someAnswer;</span></span><br><span class="line">      <span class="built_in">this</span>.props = props;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以看到在代码中，这些交互式配置都由prompts来进行维护，prompts是一个对象数组，数组中的每个元素对象就代表着一个具体的安装提示，在使用yo命令运行该生成器的时候，它的执行情况如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     _-----_     ╭──────────────────────────╮</span><br><span class="line">    |       |    │         欢迎使用            │</span><br><span class="line">    |--(o)--|    │      generator-wen!        │</span><br><span class="line">   `---------´   │      Author：文顶顶         │</span><br><span class="line">    ( _´U`_ )    ╰──────────────────────────╯</span><br><span class="line">    /___A___\   /</span><br><span class="line">     |  ~  |     </span><br><span class="line">   __&#x27;.___.&#x27;__   </span><br><span class="line"> ´   `  |° ´ Y `</span><br><span class="line"></span><br><span class="line">? 请输入项目名称: wendingdingTest</span><br><span class="line">? 请输入作者姓名: 文顶顶</span><br><span class="line">? 请选择使用的license: Apache-2.0</span><br><span class="line">? 是否需要使用bootStrap框架？ (y/N) yes</span><br></pre></td></tr></table></figure>
<p>prompts中的每个对象元素就代表着一个安装提示，上面代码一共提供了四个安装提示。每个对象中的type属性用于表明交互的类型，其中输入项目名称和作者姓名是<code>input型的</code>,表示接收用户的输入，相当于填空题。选择使用的license是<code>list</code>型的，它提供了多个选项供用户选择，您可以认为这种类型是单选题。是否需要使用bootStrap框架是<code>confirm</code>型的，默认为false，如果需要安装那么需要输入YES，这相当于是非题。</p>
<div class='tip'>交互式配置这部分可以根据项目的实际情况来设置prompts中的对象元素，除上面介绍的这些类型外，您还可以通过查看[inquirer.js的文档](https://www.npmjs.com/package/inquirer)来获取更多内容。</div>

<p>交互式配置过程中用户做出的所有选择和输入都会被保存到this.props对象中，可以通过访问this.props.isIncludeBootstrap属性来确定是否需要安装Bootstrap。</p>
<p><code>message属性</code>保存是每一条安装提示的提示信息。<br><code>name属性</code>是最重要的属性之一，它作为key用来访问用户的选择结果。<br><code>default属性</code>保存的是默认值，即当用户跳过当前安装提示的时候，name对应的value值将使用default中保存的默认值来设置。</p>
<p><strong>② 写入文件</strong></p>
<p>写入文件这个过程会把项目模板复制到指定的目录中，如果是固定文件那么就直接拷贝，如果是灵活文件那么还需要把某些参数传递给指定的模板文件。这个过程在代码中由writing() 函数体现，另外系统还提供了两个函数（<code>fs.copyTpl和fs.copy</code>）用来执行具体的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">writing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    mkdirp(<span class="string">&quot;build&quot;</span>);          <span class="comment">//创建build文件目录</span></span><br><span class="line">    mkdirp(<span class="string">&quot;dist&quot;</span>);           <span class="comment">//创建dist文件目录</span></span><br><span class="line">    mkdirp(<span class="string">&quot;src/template&quot;</span>);   <span class="comment">//创建src/template文件目录</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//传递参数this.props.appName渲染index.html文件</span></span><br><span class="line">	<span class="comment">//把项目模板中的index.html文件复制到新项目的src路径下</span></span><br><span class="line">    <span class="built_in">this</span>.fs.copyTpl(</span><br><span class="line">      <span class="built_in">this</span>.templatePath(<span class="string">&#x27;index.html&#x27;</span>),</span><br><span class="line">      <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;src/index.html&#x27;</span>),</span><br><span class="line">      &#123;<span class="attr">appName</span>: <span class="built_in">this</span>.props.appName&#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把项目模板中的style.css文件复制到新项目的src/css路径下</span></span><br><span class="line">    <span class="built_in">this</span>.fs.copy(</span><br><span class="line">      <span class="built_in">this</span>.templatePath(<span class="string">&#x27;css/style.css&#x27;</span>),</span><br><span class="line">      <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;src/css/style.css&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style='color:#195'>fs.copy方法会把指定文件复制到目标路径。</span><br><span style='color:#195'>fs.copyTpl方法会先传递参数给模板文件，经过模板引擎处理后再进行复制。</span></p>
<p><strong>③ 下载和安装依赖</strong></p>
<p>这个阶段做的事情非常简单，就是调用npm或者是bower来下载并安装依赖和相关的node模块。Yeoman提供了几个对应的方法来处理这个过程。</p>
<p><strong><code>this.npmInstall()</code></strong><br> 使用Npm来安装package.json中的依赖和模块，相当于在终端中输入<code>$ npm install</code>指令。</p>
<p><strong><code>this.bowerInstall()</code></strong><br>使用Bower来安装bower.json中的依赖和模块，相当于在终端中输入<code>$ bower install</code>指令。</p>
<p><strong><code>this.installDependencies()</code></strong><br>调用Bower和Npm并且安装package.json和bower.json中依赖的所有模块，相当于先后调用了npmInstall和bowerInstall方法。</p>
<p>最后，为了帮助更好的理解Yeoman组装流程的三个阶段，给出下面的示意图。<br><img src='../../../../src/yeoman06.png'></p>
<img src='../../../../z.png' width="200px">

<hr>
<ul>
<li>Posted by 博客园·<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a> | <a target="_blank" rel="noopener" href="http://wendingding.com/">花田半亩</a></li>
<li>联系作者 简书·<a target="_blank" rel="noopener" href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&mod=TAB#place">Coder_文顶顶</a></li>
<li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a target="_blank" rel="noopener" href="http://www.cnblogs.com/wendingding/">文顶顶</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/05/28/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B07%5D%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6generator%E5%88%9B%E5%BB%BA/" class="prev">上一篇</a><a href="/2018/05/23/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B05%5D%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://weibo.com/u/3800117445">文顶顶</a> &nbsp;☁ 全站字数统计 418.8k (字)</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>